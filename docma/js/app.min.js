/* global docma, dust, hljs, $ */
/* eslint camelcase:0 */

(function () {
    'use strict';

    var MIN_FONT_SIZE = 10;
    var MAX_FONT_SIZE = 14;
    var RE_EXAMPLE_CAPTION = /^\s*<caption>(.*?)<\/caption>\s*/gi;
    // CAUTION: if modifying these constants, also update less vars in
    // sidebar.less
    var NAVBAR_HEIGHT = 50;
    var SIDEBAR_NODE_HEIGHT = 40;
    var TREE_NODE_WIDTH = 20;

    var templateOpts = docma.template.options;

    var $sidebarNodes, $btnClean, $txtSearch;
    var $wrapper, $sidebarWrapper, $pageContentWrapper, $sidebarToggle;
    var isFilterActive = false;
    var isApiRoute = false;

    // ---------------------------
    // HELPER METHODS
    // ---------------------------

    // Adjusts font-size of each sidebar node's label so that they are not
    // cropped.
    function setFontSize($el) {
        var f = MAX_FONT_SIZE;
        while ($el.width() > 215 && f >= MIN_FONT_SIZE) {
            f--;
            $el.css('font-size', f + 'px');
        }
    }

    function getSymbolInfo(symbolKind, asButton) {

        function html(cls, title, str) {
            str = '<div class="item-badge" title="' + title + '">'
                + '<div class="badge-label">' + str + '</div>'
                + '<div class="badge-shape ' + cls + '"></div>'
                + '</div>';
            return asButton ? '<div class="badge-button">' + str + '</div>' : str;
        }

        var badge, char;

        switch (symbolKind) {
            case 'class':
                char = 'C';
                badge = html('diamond bg-green', 'Class', char);
                break;
            case 'constructor':
                char = 'C';
                badge = html('circle bg-purple', 'Constructor', char);
                break;
            case 'namespace':
                char = 'N';
                badge = html('diamond bg-pink', 'Namespace', char);
                break;
            case 'module':
                char = 'M';
                badge = html('diamond bg-pink', 'Module', char);
                break;
            case 'enum':
                char = 'E';
                badge = html('square bg-purple', 'Enum', char);
                break;
            case 'global':
                char = 'G';
                badge = html('diamond bg-red', 'Global', char);
                break;
            case 'global-object':
                char = 'G';
                badge = html('diamond bg-red', 'Global Object', char);
                break;
            case 'global-function':
                char = 'G';
                badge = html('diamond bg-accent', 'Global Function', char);
                break;
            case 'inner':
                char = 'I';
                badge = html('circle bg-gray-dark', 'Inner', char);
                break;
            case 'inner-method':
                char = 'M';
                badge = html('circle bg-gray-dark', 'Inner Method', char);
                break;
            case 'static-property':
                char = 'P';
                badge = html('square bg-orange', 'Static Property', char);
                break;
            case 'static-method':
                char = 'M';
                badge = html('square bg-accent', 'Static Method', char);
                break;
            case 'instance-property':
                char = 'P';
                badge = html('circle bg-yellow', 'Instance Property', char);
                break;
            case 'instance-method':
                char = 'M';
                badge = html('circle bg-cyan', 'Instance Method', char);
                break;
            case 'function':
                char = 'F';
                badge = html('square bg-accent', 'Function', char);
                break;
            default:
                char = '';
                badge = '';
        }
        return {
            kind: symbolKind,
            char: char,
            badge: badge
        };
    }

    function getSymbolData(symbol) {
        var none = {
            kind: '',
            char: '',
            badge: ''
        };
        if (!symbol) return none;

        if (docma.utils.isClass(symbol)) return getSymbolInfo('class');
        if (docma.utils.isConstructor(symbol)) return getSymbolInfo('constructor');
        if (docma.utils.isNamespace(symbol)) return getSymbolInfo('namespace');
        if (docma.utils.isModule(symbol)) return getSymbolInfo('module');
        if (docma.utils.isEnum(symbol)) return getSymbolInfo('enum');
        if (docma.utils.isGlobal(symbol)) {
            return docma.utils.isMethod(symbol)
                ? getSymbolInfo('global-function')
                : getSymbolInfo('global-object');
        }
        if (docma.utils.isInner(symbol)) {
            return docma.utils.isMethod(symbol)
                ? getSymbolInfo('inner-method')
                : getSymbolInfo('inner');
        }
        if (docma.utils.isStaticProperty(symbol)) return getSymbolInfo('static-property');
        if (docma.utils.isInstanceProperty(symbol)) return getSymbolInfo('instance-property');
        if (docma.utils.isStaticMethod(symbol)) return getSymbolInfo('static-method');
        if (docma.utils.isInstanceMethod(symbol)) return getSymbolInfo('instance-method');
        if (docma.utils.isMethod(symbol)) {
            return getSymbolInfo('function');
        }
        return none;
    }

    function colorOperators(str) {
        return str.replace(/[.#~:]/g, '<span class="color-blue">$&</span>');
    }

    function getTreeLine(treeNode, marginLeft) {
        marginLeft = marginLeft || 0;
        return '<img class="item-tree-line" src="img/tree-' + treeNode + '.png" width="' + TREE_NODE_WIDTH + 'px" height="' + SIDEBAR_NODE_HEIGHT + 'px" style="margin-left:' + marginLeft + 'px;" />';
    }

    // treeNode: 'first', 'last' or 'node' (or 'deep' which is calculated)
    function getTreeLineImgs(levels, treeNode) {
        var marginLeft = -TREE_NODE_WIDTH;
        // this will be checked and src might be changed to img/tree-last.png if
        // this is the last item of a tree node.

        var imgs = [];
        if (treeNode === 'first') {
            if (levels > 1) return getTreeLineImgs(levels, 'node');
            // imgs = []; // keep it empty
        } else {
            // badge node
            imgs = [getTreeLine(treeNode)];
        }

        if (levels > 2) {
            var i, ml;
            for (i = 2; i < levels; i++) {
                ml = (i - 2) * marginLeft;
                imgs.unshift(getTreeLine('deep', ml));
            }
        }
        return imgs.join('');
    }

    function getSidebarNavItemInner(badge, symbolName, treeNode) {
        var levels = ((symbolName || '').split(/[.#~:]/) || []).length;
        var name =
        // docma.utils.isConstructor(symbol) ? name + ' [constructor]' :
            dust.filters.$dot_prop(symbolName);
        return '<span class="item-inner" data-levels="' + levels + '" style="margin-left:0px">'
            + getTreeLineImgs(levels, treeNode)
            + badge
            + '<span class="item-label">' + name + '</span>'
            + '</span>';
    }

    function buildSidebarNodes(symbolNames, symbols, parentSymbol) {
        symbols = symbols || docma.documentation;
        var items = [];
        symbols.forEach(function (symbol, index) {
            // don't add nav item if symbol is not in symbolNames list
            if (symbolNames.indexOf(symbol.$longname) === -1) return;
            items.push(getSidebarNavItem(symbol, parentSymbol, index === symbols.length - 1));
            if (symbol.$members) {
                var memberItems = buildSidebarNodes(symbolNames, symbol.$members, symbol);
                items = items.concat(memberItems);
            }
        });
        return items;
    }

    function getSidebarNavItem(symbol, parentSymbol, isLast) {
        var treeNode = parentSymbol
            ? isLast ? 'last' : 'node'
            : 'first';
        var id = dust.filters.$id(symbol);
        var keywords = docma.utils.getKeywords(symbol);
        var symbolData = getSymbolData(symbol);
        // .badges also accepts string
        var badge = templateOpts.badges === true
            ? symbolData.badge || ''
            : (typeof templateOpts.badges === 'string' ? templateOpts.badges : '&nbsp;•&nbsp;');
        var innerHTML = getSidebarNavItemInner(badge, symbol.$longname, treeNode);
        return '<li><a href="#' + id + '" class="sidebar-item" data-keywords="' + keywords + '" data-kind="' + symbolData.kind + '">' + innerHTML + '</a></li>';
    }

    function setSidebarNodesOutline(outline) {
        outline = outline || templateOpts.outline;
        var isTree = outline === 'tree';

        if (isTree) {
            $('.sidebar-nav .item-tree-line').show();
        } else {
            $('.sidebar-nav .item-tree-line').hide();
        }

        var inners = $('.sidebar-nav .item-inner');
        if (isTree) {
            inners.find('.symbol-memberof').addClass('no-width'); // hide
        } else {
            inners.find('.symbol-memberof').removeClass('no-width'); // show
        }

        // move this out for performance
        // .badges also accepts string
        inners.find('.item-label').css('margin-left', templateOpts.badges === true ? '12px' : '0');

        $('.sidebar-nav .item-inner').each(function () {
            var item = $(this);

            var memberof = item.find('.symbol-memberof');
            if (isTree) {
                memberof.addClass('no-width'); // .hide();
            } else {
                memberof.removeClass('no-width'); // .show();
            }

            var label = item.find('.item-label');
            // .badges also accepts string
            label.css('margin-left', templateOpts.badges === true ? '12px' : '0');
            // css transition duration is .2s
            var delay = templateOpts.animations ? 210 : 0;
            setTimeout(function () {
                label.css('font-size', MAX_FONT_SIZE + 'px');
                setFontSize(label);
            }, delay);
        });
    }

    function cleanFilter() {
        if (!templateOpts.sidebar) return;

        $('.badge-button').removeClass('active');
        if ($txtSearch) $txtSearch.val('').focus();
        // reset outline back to initial value
        setSidebarNodesOutline(templateOpts.outline);
        $sidebarNodes.show();
        if ($btnClean) $btnClean.hide();
        $('.toolbar-buttons > span').css('color', '#fff');
        isFilterActive = false;
    }

    // Sets "flat" outline for the sidebar nodes. This wrapped in a function to
    // be passed to the last node's anim method callback argument. We set
    // outline to "flat" bec. if outline is "tree", and some symbol parent does
    // not match the search/filter, it (the indents) looks weird.
    function cbSetSidebarNodesOutline() {
        setSidebarNodesOutline('flat');
    }

    function filterSidebarNodes(strSearch) {
        if (!templateOpts.sidebar) return;

        var search = (strSearch || '').trim().toLowerCase();
        if (search === '') {
            cleanFilter();
            return;
        }
        if ($btnClean) $btnClean.show();

        isFilterActive = true;

        // e.g. search filter » "kind:instance-method"
        var reSym = /^\s*kind\s*:\s*/i;
        var filterByKind = reSym.test(search)
            ? search.replace(reSym, '').replace(/[ ]+/g, '-')
            : null;

        $('.badge-button').removeClass('active');

        var data;
        var attr = filterByKind ? 'data-kind' : 'data-keywords';
        var find = filterByKind ? filterByKind : search;
        $sidebarNodes.each(function (index) {
            // callback to be passed to the last node's anim method, so that
            // outline is animated after all nodes are anim'ed-out. this is for
            // better performance.
            var cb = index === $sidebarNodes.length - 1
                ? cbSetSidebarNodesOutline
                : $.noop;
            // get the data to be searched from each node's target attribute.
            data = $(this).attr(attr);
            if (data.indexOf(find) < 0) {
                if (templateOpts.animations) {
                    $(this).slideUp('fast', cb);
                } else {
                    $(this).hide('fast', cb);
                }
            } else {
                $(this).show('fast', cb);
                // $(this).slideDown('fast', cb);
            }
        });

        $('.toolbar-buttons > span').css('color', '#7b8395');
    }

    // ---------------------------
    // CUSTOM DUST FILTERS
    // ---------------------------

    docma
        .addFilter('$color_ops', function (name) {
            return colorOperators(name);
        })
        .addFilter('$dot_prop', function (name) {
            var re = /(.*)([.#~:]\w+)/g,
                match = re.exec(name);
            if (!match) return '<b>' + name + '</b>';
            var cls = templateOpts.animations ? ' trans-all-ease-fast' : '';
            return '<span class="color-gray symbol-memberof' + cls + '">' + colorOperators(match[1]) + '</span><span>' + colorOperators(match[2]) + '</span>';
        })
        .addFilter('$author', function (symbol) {
            var authors = Array.isArray(symbol) ? symbol : (symbol.author || []);
            return authors.join(', ');
        })
        .addFilter('$type', function (symbol) {
            if (docma.utils.isConstructor(symbol)) return '';
            if (symbol.kind === 'function') {
                var returnTypes = docma.utils.getReturnTypes(symbol);
                return returnTypes ? returnTypes : '';
            }
            var types = docma.utils.getTypes(symbol);
            return types ? types : '';
        })
        .addFilter('$type_sep', function (symbol) {
            if (docma.utils.isConstructor(symbol)) return '';
            if (symbol.kind === 'function') return '⇒';
            if (symbol.kind === 'class') return ':';
            if (!symbol.type && !symbol.returns) return '';
            return ':';
        })
        .addFilter('$param_desc', function (param) {
            var str = !param.optional
                ? '<span class="boxed bg-red">Required</span>&nbsp;'
                : '';
            str += param.description;
            return docma.utils.parse(str);
        })
        .addFilter('$longname', function (symbol) {
            if (typeof symbol === 'string') return symbol;
            var nw = docma.utils.isConstructor(symbol) ? 'new ' : '';
            return nw + symbol.$longname; // docma.utils.getFullName(symbol);
        })
        .addFilter('$longname_params', function (symbol) {
            var isCon = docma.utils.isConstructor(symbol),
                longName = colorOperators(symbol.$longname); // docma.utils.getFullName(symbol);
            if (symbol.kind === 'function' || isCon) {
                var defVal,
                    defValHtml = '',
                    nw = isCon ? 'new ' : '',
                    name = nw + longName + '(';
                if (Array.isArray(symbol.params)) {
                    var params = symbol.params.reduce(function (memo, param) {
                        // ignore params such as options.<property>
                        if (param && param.name.indexOf('.') === -1) {
                            defVal = param.hasOwnProperty('defaultvalue') ? String(param.defaultvalue) : 'undefined';
                            defValHtml = param.optional
                                ? '<span class="def-val">=' + defVal + '</span>'
                                : '';
                            memo.push(param.name + defValHtml);
                        }
                        return memo;
                    }, []).join(', ');
                    name += params;
                }
                return name + ')';
            }
            return longName;
        })
        .addFilter('$extends', function (symbol) {
            var ext = Array.isArray(symbol) ? symbol : symbol.augments;
            return docma.utils.listType(ext);
        })
        .addFilter('$returns', function (symbol) {
            var returns = Array.isArray(symbol) ? symbol : symbol.returns;
            return docma.utils.listTypeDesc(returns);
        })
        .addFilter('$exceptions', function (symbol) {
            var exceptions = Array.isArray(symbol) ? symbol : symbol.exceptions;
            return docma.utils.listTypeDesc(exceptions);
        })
        // non-standard JSDoc directives are stored in `.tags` property of a
        // symbol. We also add other properties such as .access (if not public),
        // `.readonly` or `.kind=namespace` as tags.
        .addFilter('$tags', function (symbol) {
            var open = '<span class="boxed vertical-middle bg-ice opacity-full">',
                open2 = '<span class="boxed vertical-middle bg-ice-mid opacity-full">',
                open3 = '<span class="boxed vertical-middle">',
                open4 = '<span class="boxed vertical-middle bg-ice-dark opacity-full">',
                open5 = '<span class="boxed vertical-middle bg-blue opacity-full">',
                open6 = '<span class="boxed vertical-middle bg-warning color-brown opacity-full">',
                open7 = '<span class="boxed vertical-middle bg-purple color-white opacity-full">',
                close = '</span>',
                tagBoxes = [];

            if (docma.utils.isDeprecated(symbol)) {
                tagBoxes.push(open6 + 'deprecated' + close);
            }
            if (docma.utils.isGlobal(symbol) && !docma.utils.isConstructor(symbol)) {
                tagBoxes.push(open7 + 'global' + close);
            }
            if (docma.utils.isConstructor(symbol)) {
                tagBoxes.push(open + 'constructor' + close);
            }
            if (docma.utils.isStatic(symbol)) {
                tagBoxes.push(open5 + 'static' + close);
            }
            if (docma.utils.isPublic(symbol) === false) {
                tagBoxes.push(open4 + symbol.access + close);
            }
            if (docma.utils.isNamespace(symbol)) {
                tagBoxes.push(open + 'namespace' + close);
            }
            if (docma.utils.isReadOnly(symbol)) {
                tagBoxes.push(open3 + 'readonly' + close);
            }

            var tags = Array.isArray(symbol) ? symbol : symbol.tags || [],
                tagTitles = tags.map(function (tag) {
                    return open2 + tag.originalTitle + close;
                });
            tagBoxes = tagBoxes.concat(tagTitles);
            if (tagBoxes.length) return '&nbsp;&nbsp;' + tagBoxes.join('&nbsp;');
            return '';
        })
        .addFilter('$navnodes', function (symbolNames) {
            return buildSidebarNodes(symbolNames).join('');
        })
        .addFilter('$get_caption', function (example) {
            var m = RE_EXAMPLE_CAPTION.exec(example || '');
            return (m && m[1] ? ' — <i>' + docma.utils.parseTicks(m[1]) + '</i>' : '');
        })
        .addFilter('$remove_caption', function (example) {
            return (example || '').replace(RE_EXAMPLE_CAPTION, '');
        });

    // ---------------------------
    // INITIALIZATION
    // ---------------------------

    // http://highlightjs.readthedocs.org/en/latest/api.html#configure-options
    hljs.configure({
        tabReplace: '    ',
        useBR: false
    });

    if (!templateOpts.title) {
        templateOpts.title = docma.app.title || 'Documentation';
    }

    docma.on('render', function (currentRoute) { // eslint-disable-line

        isApiRoute = docma.currentRoute && docma.currentRoute.type === 'api';

        // remove empty tables (especially for classdesc)
        // trim bec. jQuery treates whitespace as non-empty
        $('table').each(function () {
            $(this).html($.trim($(this).html()));
        });
        $('table:empty').remove();

        $wrapper = $('#wrapper');
        $sidebarWrapper = $('#sidebar-wrapper');
        $pageContentWrapper = $('#page-content-wrapper');
        $sidebarToggle = $('#sidebar-toggle');

        if (templateOpts.animations) {
            $wrapper.addClass('trans-all-ease');
            $sidebarWrapper.addClass('trans-all-ease');
        } else {
            $wrapper.removeClass('trans-all-ease');
            $sidebarWrapper.removeClass('trans-all-ease');
        }

        if (!templateOpts.navbar) {
            // remove the gap created for navbar
            $('body, html').css('padding-top', 0);
            // remove sidbar top spacing
            $sidebarWrapper.css('margin-top', 0);
            // since navbar is disabled, also remove the spacing set for
            // preventing navbar overlap with bookmark'ed symbol title.
            $('.symbol-container').css({
                'padding-top': 0,
                'margin-top': 0
            });
        }

        // Brand style / margin
        var brandMargin = isApiRoute
            ? templateOpts.sidebar ? 40 : 0
            : 0;
        // var brandHPadding = isApiRoute ? 5 : 0;
        $('.navbar-brand').css({
            'margin-left': brandMargin + 'px'
            // , 'padding-left': brandHPadding + 'px',
            // 'padding-right': brandHPadding + 'px'
        });

        // Syntax-Highlight code examples
        var examples = $('#docma-main pre > code');
        examples.each(function (i, block) {
            hljs.highlightBlock(block);
        });

        if (isApiRoute === false) {

            // ----------------------------
            // CONTENT-ROUTE-ONLY SECTION
            // ----------------------------

            // For the JSDoc API documentation, our template partials already have
            // styles. So we'll style only some type of elements in other HTML
            // content.

            // We'll add the template's modified bootstrap table classes
            $('table').addClass('table table-striped table-bordered');

            // prepend link icon to bookmarks, if any
            $('.docma.bookmark a')
                .prepend('<span class="glyphicon glyphicon-link color-gray-light" aria-hidden="true"></span>');

            // code blocks in markdown files (e.g. ```js) are converted into
            // <code class="lang-js">. we'll add classes for hljs for proper
            // highlighting. e.g. for javascript, hljs requires class="js". So
            // this will be class="lang-js js".

            // this seems unnecessary. somehow, hljs detects it.
            // $("code[class^='lang-']").each(function () {
            //     var cls = $(this).attr('class'),
            //         m = cls.match(/lang\-([^ ]+)/)[1];
            //     if (m) $(this).addClass(m);
            // });

            return;
        }

        // ----------------------------
        // API-ROUTE-ONLY SECTION
        // ----------------------------

        function searchEvent() {
            if (!$txtSearch) return;
            filterSidebarNodes($txtSearch.val());
        }

        // CAUTION: if modifying this, also update less vars in sidebar.less
        var sidebarHeaderHeight = templateOpts.search ? 130 : NAVBAR_HEIGHT;
        if (templateOpts.toolbar) sidebarHeaderHeight += SIDEBAR_NODE_HEIGHT;
        $('.sidebar-nav-container').css('top', sidebarHeaderHeight);
        $('.sidebar-header').css('height', sidebarHeaderHeight);

        if (templateOpts.search) {
            $btnClean = $('.sidebar-search-clean');
            $txtSearch = $('#txt-search');

            if ($btnClean) {
                $btnClean.hide();
                $btnClean.on('click', cleanFilter);
            }

            if ($txtSearch) {
                $txtSearch.on('keyup', searchEvent);
                $txtSearch.on('change', searchEvent);
            }

        } else {
            $('.sidebar-nav').css('top', '0px');
        }

        var pageContentRow = $pageContentWrapper.find('.row').first();
        if (templateOpts.sidebar) {
            $sidebarNodes = $('ul.sidebar-nav .sidebar-item');
            setSidebarNodesOutline();
            if (!templateOpts.collapsed) {
                $wrapper.addClass('toggled');
                $sidebarToggle.addClass('toggled');
            }
            $sidebarToggle.on('click', function (event) {
                event.preventDefault();
                $wrapper.toggleClass('toggled');
                $sidebarToggle.toggleClass('toggled');
                // add some extra spacing if navbar is disabled; to prevent top
                // left toggle button to overlap with content.
                if (!templateOpts.navbar) {
                    var hasToggled = $wrapper.hasClass('toggled');
                    var marginLeft = hasToggled ? '+=30px' : '-=30px';
                    if (templateOpts.animations) {
                        pageContentRow.animate({
                            'margin-left': marginLeft
                        }, 300);
                    } else {
                        pageContentRow.css('margin-left', marginLeft);
                    }
                }
            });

            if (templateOpts.toolbar) {

                var filterButtons = getSymbolInfo('global', true).badge
                    + getSymbolInfo('namespace', true).badge
                    + getSymbolInfo('class', true).badge
                    + getSymbolInfo('instance-method', true).badge
                    + getSymbolInfo('static-method', true).badge
                    + getSymbolInfo('instance-property', true).badge
                    + getSymbolInfo('static-property', true).badge
                    + getSymbolInfo('enum', true).badge;
                    // + getSymbolInfo('inner', true).badge;

                $('.toolbar-filters')
                    .html(filterButtons)
                    .find('.badge-button')
                    .on('click', function () {
                        var btn = $(this);
                        if (btn.hasClass('active')) {
                            cleanFilter();
                            return;
                        }
                        var strSearch = ($(this).find('.item-badge').attr('title') || '').toLowerCase().replace(/[ ]+/g, '-');
                        strSearch = 'kind:' + strSearch;
                        if ($txtSearch) {
                            $txtSearch.val(strSearch).focus();
                            if ($btnClean) $btnClean.show();
                        }
                        filterSidebarNodes(strSearch);
                        btn.addClass('active');
                    });

                $('.toolbar-buttons .btn-switch-outline').on('click', function () {
                    // disable if search is active
                    // if ($txtSearch && $txtSearch.val() !== '') return;
                    if (isFilterActive) return;

                    var $btn = $(this);
                    var $btni = $btn.find('i').removeClass('ico-bookmark ico-bookmarks');
                    var newOutline, newCls;
                    if (templateOpts.outline === 'flat') {
                        newOutline = 'tree';
                        newCls = 'ico-bookmarks';
                    } else {
                        newOutline = 'flat';
                        newCls = 'ico-bookmark';
                    }
                    templateOpts.outline = newOutline;
                    $btni.addClass(newCls);
                    setSidebarNodesOutline(newOutline);
                });
            }
        } else { // if (templateOpts.sidebar === false)
            // collapse the sidebar since it's disabled
            $wrapper.removeClass('toggled');
            $sidebarToggle.removeClass('toggled');
        }

    });

})();
