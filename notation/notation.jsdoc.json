[
  {
    "comment": "/**\n *  Notation.js for Node and Browser.\n *\n *  Like in most programming languages, JavaScript makes use of dot-notation to\n *  access the value a member of an object (or class). While accessing the\n *  value of the object property; notation also indicates the path of the target\n *  property.\n *\n *  `Notation` class provides various methods for modifying / processing the\n *  contents of the given object; by parsing object notation strings or globs.\n *\n *  Note that this class will only deal with enumerable properties of the\n *  source object; so it should be used to manipulate data objects. It will\n *  not deal with preserving the prototype-chain of the given object.\n *\n *  @author   Onur Yıldırım (onur@cutepilot.com)\n *  @license  MIT\n */",
    "meta": {
      "range": [
        1303,
        39117
      ],
      "filename": "notation.js",
      "lineno": 37,
      "path": "/Users/oy/Developer/javascript/notation/src/core",
      "code": {
        "id": "astnode100000689",
        "name": "Notation",
        "type": "ClassDeclaration",
        "paramnames": [
          "object"
        ]
      }
    },
    "classdesc": "Notation.js for Node and Browser.\n\n Like in most programming languages, JavaScript makes use of dot-notation to\n access the value a member of an object (or class). While accessing the\n value of the object property; notation also indicates the path of the target\n property.\n\n `Notation` class provides various methods for modifying / processing the\n contents of the given object; by parsing object notation strings or globs.\n\n Note that this class will only deal with enumerable properties of the\n source object; so it should be used to manipulate data objects. It will\n not deal with preserving the prototype-chain of the given object.",
    "author": [
      "Onur Yıldırım (onur@cutepilot.com)"
    ],
    "license": "MIT",
    "name": "Notation",
    "longname": "Notation",
    "kind": "class",
    "scope": "global",
    "description": "Initializes a new instance of `Notation`.",
    "params": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "defaultvalue": "{}",
        "description": "The source object to be notated.",
        "name": "object"
      }
    ],
    "$longname": "Notation",
    "$members": [
      {
        "comment": "/**\n     *  Clones the `Notation` instance to a new one.\n     *\n     *  @returns {Notation} - A new copy of the instance.\n     */",
        "meta": {
          "range": [
            24598,
            24689
          ],
          "filename": "notation.js",
          "lineno": 645,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001731",
            "name": "Notation#clone",
            "type": "MethodDefinition",
            "paramnames": []
          },
          "vars": {
            "": null
          }
        },
        "description": "Clones the `Notation` instance to a new one.",
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- A new copy of the instance."
          }
        ],
        "name": "clone",
        "longname": "Notation#clone",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "params": [],
        "$longname": "Notation#clone"
      },
      {
        "comment": "/**\n     *  Copies the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the copied property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  on the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */",
        "meta": {
          "range": [
            27705,
            28054
          ],
          "filename": "notation.js",
          "lineno": 713,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001803",
            "name": "Notation#copyFrom",
            "type": "MethodDefinition",
            "paramnames": [
              "destination",
              "notation",
              "newNotation",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Copies the notated property from the destination object and adds it to the\n source object — only if the destination object actually has that property.\n This is different than a property with a value of `undefined`.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "The destination object that the notated\n properties will be copied from.",
            "name": "destination"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding property\n from the destination object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "optional": true,
            "defaultvalue": null,
            "description": "The notation to set the destination\n property on the source object. In other words, the copied property\n will be renamed to this value before set on the source object.\n If not set, `notation` argument will be used.",
            "name": "newNotation"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property\n on the source object if it exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var models = { dodge: \"Charger\" };\n Notation.create(assets).copyFrom(models, \"dodge\", \"car.model\", true);\n console.log(assets);\n // { car: { brand: \"Ford\", model: \"Charger\" } }\n // models object is not modified"
        ],
        "name": "copyFrom",
        "longname": "Notation#copyFrom",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#copyFrom"
      },
      {
        "comment": "/**\n     *  Copies the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // assets object is not modified\n     */",
        "meta": {
          "range": [
            26011,
            26358
          ],
          "filename": "notation.js",
          "lineno": 677,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001749",
            "name": "Notation#copyTo",
            "type": "MethodDefinition",
            "paramnames": [
              "destination",
              "notation",
              "newNotation",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Copies the notated property from the source object and adds it to the\n destination — only if the source object actually has that property.\n This is different than a property with a value of `undefined`.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "The destination object that the notated\n properties will be copied to.",
            "name": "destination"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding property\n from the source object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "optional": true,
            "defaultvalue": null,
            "description": "The notation to set the source property\n on the destination object. In other words, the copied property will be\n renamed to this value before set on the destination object. If not set,\n `notation` argument will be used.",
            "name": "newNotation"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property on\n the destination object if it exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var models = { dodge: \"Charger\" };\n Notation.create(assets).copyTo(models, \"car.model\", \"ford\");\n console.log(models);\n // { dodge: \"Charger\", ford: \"Mustang\" }\n // assets object is not modified"
        ],
        "name": "copyTo",
        "longname": "Notation#copyTo",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#copyTo"
      },
      {
        "comment": "/**\n     *  Basically constructs a new `Notation` instance with the given object.\n     *  @chainable\n     *\n     *  @param {Object} [object={}] - The object to be notated.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  var notaObj = Notation.create(obj);\n     *  // equivalent to:\n     *  var notaObj = new Notation(obj);\n     */",
        "meta": {
          "range": [
            35608,
            35679
          ],
          "filename": "notation.js",
          "lineno": 914,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002069",
            "name": "Notation.create",
            "type": "MethodDefinition",
            "paramnames": [
              "object"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Basically constructs a new `Notation` instance with the given object.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "optional": true,
            "defaultvalue": "{}",
            "description": "The object to be notated.",
            "name": "object"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- The created instance."
          }
        ],
        "examples": [
          "var notaObj = Notation.create(obj);\n // equivalent to:\n var notaObj = new Notation(obj);"
        ],
        "name": "create",
        "longname": "Notation.create",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.create"
      },
      {
        "comment": "/**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *  @alias Notation#eachKey\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(carInfo).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */",
        "meta": {
          "range": [
            3474,
            4090
          ],
          "filename": "notation.js",
          "lineno": 106,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000727",
            "name": "Notation#each",
            "type": "MethodDefinition",
            "paramnames": [
              "callback"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Recursively iterates through each key of the source object and invokes\n the given callback function with parameters, on each non-object value.",
        "alias": "Notation#eachKey",
        "params": [
          {
            "type": {
              "names": [
                "function"
              ]
            },
            "description": "The callback function to be invoked on\n each on each non-object value. To break out of the loop, return `false`\n from within the callback.\n Callback signature: `callback(notation, key, value, object) { ... }`",
            "name": "callback"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "void"
              ]
            }
          }
        ],
        "examples": [
          "var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n Notation.create(carInfo).each(function (notation, key, value, object) {\n     console.log(notation, value);\n });\n // \"car.brand\"  \"Dodge\"\n // \"car.model\"  \"Charger\"\n // \"car.year\"  1970"
        ],
        "name": "eachKey",
        "longname": "Notation#eachKey",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#each"
      },
      {
        "comment": "/**\n     *  Iterates through each note of the given notation string.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  Notation.eachNote(\"first.prop2.last\", function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0 \"first\" \"first\"\n     *  // 1 \"first.prop2\" \"prop2\"\n     *  // 2 \"first.prop2.last\" \"last\"\n     */",
        "meta": {
          "range": [
            38604,
            39114
          ],
          "filename": "notation.js",
          "lineno": 1011,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002206",
            "name": "Notation.eachNote",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "callback"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Iterates through each note of the given notation string.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be iterated through.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "function"
              ]
            },
            "description": "The callback function to be invoked on\n each iteration. To break out of the loop, return `false` from within the\n callback.\n Callback signature: `callback(levelNotation, note, index, list) { ... }`",
            "name": "callback"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "void"
              ]
            }
          }
        ],
        "examples": [
          "Notation.eachNote(\"first.prop2.last\", function (levelNotation, note, index, list) {\n     console.log(index, note, levelNotation);\n });\n // 0 \"first\" \"first\"\n // 1 \"first.prop2\" \"prop2\"\n // 2 \"first.prop2.last\" \"last\""
        ],
        "name": "eachNote",
        "longname": "Notation.eachNote",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.eachNote"
      },
      {
        "comment": "/**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback.\n     *  Callback signature: `callback(levelValue, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(carInfo)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */",
        "meta": {
          "range": [
            5021,
            5472
          ],
          "filename": "notation.js",
          "lineno": 151,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000828",
            "name": "Notation#eachValue",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "callback"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Iterates through each note of the given notation string by evaluating\n it on the source object.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be iterated through.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "function"
              ]
            },
            "description": "The callback function to be invoked on\n each iteration. To break out of the loop, return `false` from within\n the callback.\n Callback signature: `callback(levelValue, note, index, list) { ... }`",
            "name": "callback"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "void"
              ]
            }
          }
        ],
        "examples": [
          "var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n Notation.create(carInfo)\n     .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n         console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     });"
        ],
        "name": "eachValue",
        "longname": "Notation#eachValue",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#eachValue"
      },
      {
        "comment": "/**\n *  Error class specific to `Notation`.\n *  @name Notation.Error\n *  @memberof! Notation\n *  @class\n *\n */",
        "meta": {
          "range": [
            36,
            146
          ],
          "filename": "notation.error.js",
          "lineno": 4,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {}
        },
        "description": "Error class specific to `Notation`.",
        "name": ".Error",
        "forceMemberof": true,
        "memberof": "Notation",
        "kind": "class",
        "longname": "Notation.Error",
        "scope": "global",
        "$longname": "Notation.Error"
      },
      {
        "comment": "/**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var carInfo = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  var expanded = Notation.create(carInfo).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */",
        "meta": {
          "range": [
            7355,
            7462
          ],
          "filename": "notation.js",
          "lineno": 216,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000958",
            "name": "Notation#expand",
            "type": "MethodDefinition",
            "paramnames": []
          },
          "vars": {
            "": null
          }
        },
        "description": "Aggregates notated keys of a (single-level) object, and nests them under\n their corresponding properties. This is the opposite of `Notation#flatten`\n method. This might be useful when expanding a flat object fetched from\n a database.",
        "alias": "Notation#aggregate",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var carInfo = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n var expanded = Notation.create(carInfo).expand().value;\n console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };"
        ],
        "name": "aggregate",
        "longname": "Notation#aggregate",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "params": [],
        "$longname": "Notation#expand"
      },
      {
        "comment": "/**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extracted = Notation.create(assets).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // assets object is not modified\n     */",
        "meta": {
          "range": [
            33624,
            33747
          ],
          "filename": "notation.js",
          "lineno": 850,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002003",
            "name": "Notation#extract",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "newNotation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Extracts the property at the given notation to a new object by copying\n it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.",
        "alias": "Notation#copyToNew",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding\n property (value) from the source object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The new notation to be set on the new\n object for the targeted property value. If not set, `notation` argument\n will be used.",
            "name": "newNotation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "- Returns a new object with the notated property."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var extracted = Notation.create(assets).extract(\"car.brand\", \"carBrand\");\n console.log(extracted);\n // { carBrand: \"Ford\" }\n // assets object is not modified"
        ],
        "name": "copyToNew",
        "longname": "Notation#copyToNew",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#extract"
      },
      {
        "comment": "/**\n     *  Extrudes the property at the given notation to a new object by moving\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extruded = Notation.create(assets).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(assets);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */",
        "meta": {
          "range": [
            34830,
            34953
          ],
          "filename": "notation.js",
          "lineno": 884,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002036",
            "name": "Notation#extrude",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "newNotation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Extrudes the property at the given notation to a new object by moving\n it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.",
        "alias": "Notation#moveToNew",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding\n property (value) from the source object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The new notation to be set on the new\n object for the targeted property value. If not set, `notation` argument\n will be used.",
            "name": "newNotation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "- Returns a new object with the notated property."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var extruded = Notation.create(assets).extrude(\"car.brand\", \"carBrand\");\n console.log(assets);\n // { car: { model: \"Mustang\" } }\n console.log(extruded);\n // { carBrand: \"Ford\" }"
        ],
        "name": "moveToNew",
        "longname": "Notation#moveToNew",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#extrude"
      },
      {
        "comment": "/**\n     *  Deep clones the source object while filtering its properties\n     *  by the given glob notations. Includes all matched properties\n     *  and removes the rest.\n     *\n     *  @param {Array|String} globNotations - The glob notation(s) to\n     *  be processed. The difference between normal notations and\n     *  glob-notations is that you can use wildcard stars (*) and\n     *  negate the notation by prepending a bang (!). A negated\n     *  notation will be excluded. Order of the globs do not matter,\n     *  they will be logically sorted. Loose globs will be processed\n     *  first and verbose globs or normal notations will be processed\n     *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n     *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n     *  will empty the source object.\n     *  @chainable\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     *  var nota = Notation.create(assets);\n     *  nota.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n     *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  nota.filter(\"*\");\n     *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  nota.filter(); // or nota.filter(\"\");\n     *  console.log(assets); // {}\n     */",
        "meta": {
          "range": [
            20029,
            23665
          ],
          "filename": "notation.js",
          "lineno": 536,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001471",
            "name": "Notation#filter",
            "type": "MethodDefinition",
            "paramnames": [
              "globNotations"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Deep clones the source object while filtering its properties\n by the given glob notations. Includes all matched properties\n and removes the rest.",
        "params": [
          {
            "type": {
              "names": [
                "Array",
                "String"
              ]
            },
            "description": "The glob notation(s) to\n be processed. The difference between normal notations and\n glob-notations is that you can use wildcard stars (*) and\n negate the notation by prepending a bang (!). A negated\n notation will be excluded. Order of the globs do not matter,\n they will be logically sorted. Loose globs will be processed\n first and verbose globs or normal notations will be processed\n last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n `[ \"*\", \"!car.*\", \"car.model\" ]`.\n Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n will empty the source object.",
            "name": "globNotations"
          }
        ],
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n var nota = Notation.create(assets);\n nota.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n nota.filter(\"*\");\n console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n nota.filter(); // or nota.filter(\"\");\n console.log(assets); // {}"
        ],
        "name": "filter",
        "longname": "Notation#filter",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#filter"
      },
      {
        "comment": "/**\n     *  Gets the first (root) note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */",
        "meta": {
          "range": [
            36445,
            36700
          ],
          "filename": "notation.js",
          "lineno": 945,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002096",
            "name": "Notation.first",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the first (root) note of the notation string.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be processed.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "String"
              ]
            }
          }
        ],
        "examples": [
          "Notation.first('first.prop2.last'); // \"first\""
        ],
        "name": "first",
        "longname": "Notation.first",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.first"
      },
      {
        "comment": "/**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var flat = Notation.create(carInfo).flatten().value;\n     *  console.log(flat); // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */",
        "meta": {
          "range": [
            6461,
            6662
          ],
          "filename": "notation.js",
          "lineno": 191,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000925",
            "name": "Notation#flatten",
            "type": "MethodDefinition",
            "paramnames": []
          },
          "vars": {
            "": null
          }
        },
        "description": "Flattens the source object to a single-level object with notated keys.",
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n var flat = Notation.create(carInfo).flatten().value;\n console.log(flat); // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }"
        ],
        "name": "flatten",
        "longname": "Notation#flatten",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "params": [],
        "$longname": "Notation#flatten"
      },
      {
        "comment": "/**\n     *  Gets the value of the corresponding property at the given\n     *  notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if\n     *  the property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     */",
        "meta": {
          "range": [
            13172,
            13310
          ],
          "filename": "notation.js",
          "lineno": 370,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001217",
            "name": "Notation#get",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "defaultValue"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the value of the corresponding property at the given\n notation.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be processed.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "optional": true,
            "description": "The default value to be returned if\n the property is not found or enumerable.",
            "name": "defaultValue"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "*"
              ]
            },
            "description": "- The value of the notated property."
          }
        ],
        "examples": [
          "Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n Notation.create({ car: {} }).get(\"car.model\"); // undefined\n Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined"
        ],
        "name": "get",
        "longname": "Notation#get",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#get"
      },
      {
        "comment": "/**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var notationsList = Notation.create(carInfo).getNotations();\n     *  // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */",
        "meta": {
          "range": [
            5850,
            6012
          ],
          "filename": "notation.js",
          "lineno": 173,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000898",
            "name": "Notation#getNotations",
            "type": "MethodDefinition",
            "paramnames": []
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the list of notations from the source object (keys).",
        "returns": [
          {
            "type": {
              "names": [
                "Array"
              ]
            },
            "description": "- An array of notation strings."
          }
        ],
        "examples": [
          "var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n var notationsList = Notation.create(carInfo).getNotations();\n // [ \"car.brand\", \"car.model\", \"car.year\" ]"
        ],
        "name": "getNotations",
        "longname": "Notation#getNotations",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "params": [],
        "$longname": "Notation#getNotations"
      },
      {
        "comment": "/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Notation.Glob\n *  @memberof! Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: \"John\", billing: { account: { id: 1, active: true } } };\n *\n *  \"billing.account.*\"  // represents `{ id: 1, active: true }`\n *  \"billing.account.id\" // represents `1`\n *  \"!billing.account.*\" // represents `{ name: \"John\" }`\n *  \"name\" // represents `\"John\"`\n *  \"*\" // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob(\"billing.account.*\");\n *  glob.test(\"billing.account.id\"); // true\n */",
        "meta": {
          "range": [
            236,
            1106
          ],
          "filename": "notation.glob.js",
          "lineno": 8,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {}
        },
        "description": "`Notation.Glob` is a utility for validating, comparing and sorting\n dot-notation globs.\n\n You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n and negate the notation by prepending a bang `!`. A star will include all\n the properties at that level and a negated notation will be excluded.",
        "name": ".Glob",
        "forceMemberof": true,
        "memberof": "Notation",
        "kind": "class",
        "examples": [
          "// for the following object;\n { name: \"John\", billing: { account: { id: 1, active: true } } };\n\n \"billing.account.*\"  // represents `{ id: 1, active: true }`\n \"billing.account.id\" // represents `1`\n \"!billing.account.*\" // represents `{ name: \"John\" }`\n \"name\" // represents `\"John\"`\n \"*\" // represents the whole object\n\n ",
          "var glob = new Notation.Glob(\"billing.account.*\");\n glob.test(\"billing.account.id\"); // true"
        ],
        "longname": "Notation.Glob",
        "scope": "global",
        "$longname": "Notation.Glob",
        "$members": [
          {
            "comment": "/**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. So this\n     *  works both for `*, store.address.street, !store.address` and\n     *  `*, store.address, !store.address.street`. For cases such as\n     *  `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} a - First notation glob to be compared.\n     *  @param {String} b - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\n     *  first and `0` if equivalent priority.\n     *\n     *  @example\n     *  var result = Notation.Glob.compare(\"prop.*.name\", \"prop.*\");\n     *  console.log(result); // 1\n     */",
            "meta": {
              "range": [
                4620,
                5787
              ],
              "filename": "notation.glob.js",
              "lineno": 146,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Compares two given notation globs and returns an integer value as a\n result. This is generally used to sort glob arrays. Loose globs (with\n stars especially closer to beginning of the glob string) and globs\n representing the parent/root of the compared property glob come first.\n Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n instance; `store.address` comes before `store.address.street`. So this\n works both for `*, store.address.street, !store.address` and\n `*, store.address, !store.address.street`. For cases such as\n `prop.id` vs `!prop.id` which represent the same property;\n the negated glob wins (comes last).",
            "name": "compare",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "String"
                  ]
                },
                "description": "First notation glob to be compared.",
                "name": "a"
              },
              {
                "type": {
                  "names": [
                    "String"
                  ]
                },
                "description": "Second notation glob to be compared.",
                "name": "b"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Number"
                  ]
                },
                "description": "- Returns `-1` if `a` comes first, `1` if `b` comes\n first and `0` if equivalent priority."
              }
            ],
            "examples": [
              "var result = Notation.Glob.compare(\"prop.*.name\", \"prop.*\");\n console.log(result); // 1"
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob.compare",
            "scope": "static",
            "$longname": "Notation.Glob.compare"
          },
          {
            "comment": "/**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *\n     *  @returns {NotationGlob}\n     *\n     *  @example\n     *  var glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  var glob = new Notation.Glob(strGlob);\n     */",
            "meta": {
              "range": [
                2651,
                3060
              ],
              "filename": "notation.glob.js",
              "lineno": 81,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Basically constructs a new `NotationGlob` instance\n with the given glob string.",
            "name": "create",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "String"
                  ]
                },
                "description": "The source notation glob.",
                "name": "glob"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "NotationGlob"
                  ]
                }
              }
            ],
            "examples": [
              "var glob = Notation.Glob.create(strGlob);\n // equivalent to:\n var glob = new Notation.Glob(strGlob);"
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob.create",
            "scope": "static",
            "$longname": "Notation.Glob.create"
          },
          {
            "comment": "/**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean}\n     */",
            "meta": {
              "range": [
                4157,
                4361
              ],
              "filename": "notation.glob.js",
              "lineno": 130,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Validates the given notation glob.",
            "name": "isValid",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "String"
                  ]
                },
                "description": "Notation glob to be validated.",
                "name": "glob"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Boolean"
                  ]
                }
              }
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob.isValid",
            "scope": "static",
            "$longname": "Notation.Glob.isValid"
          },
          {
            "comment": "/**\n     *  Sorts the notation globs in the given array by their priorities.\n     *  Loose globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. For cases\n     *  such as `prop.id` vs `!prop.id` which represent the same property; the\n     *  negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globsArray - The notation globs array to be sorted.\n     *  The passed array reference is modified.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  var globs = [\"!prop.*.name\", \"prop.*\", \"prop.id\"];\n     *  Notation.Glob.sort(globs);\n     *  // [\"prop.*\", \"prop.id\", \"!prop.*.name\"];\n     */",
            "meta": {
              "range": [
                7132,
                8038
              ],
              "filename": "notation.glob.js",
              "lineno": 205,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Sorts the notation globs in the given array by their priorities.\n Loose globs (with stars especially closer to beginning of the glob string);\n globs representing the parent/root of the compared property glob come first.\n Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n instance; `store.address` comes before `store.address.street`. For cases\n such as `prop.id` vs `!prop.id` which represent the same property; the\n negated glob wins (comes last).",
            "name": "sort",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "The notation globs array to be sorted.\n The passed array reference is modified.",
                "name": "globsArray"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                }
              }
            ],
            "examples": [
              "var globs = [\"!prop.*.name\", \"prop.*\", \"prop.id\"];\n Notation.Glob.sort(globs);\n // [\"prop.*\", \"prop.id\", \"!prop.*.name\"];"
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob.sort",
            "scope": "static",
            "$longname": "Notation.Glob.sort"
          },
          {
            "comment": "/**\n     *  Checks whether the given notation value matches the source notation glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *\n     *  @param {String} notation - The notation string to be tested.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  var glob = new Notation.Glob(\"!prop.*.name\");\n     *  glob.test(\"prop.account.name\"); // true\n     */",
            "meta": {
              "range": [
                1849,
                2229
              ],
              "filename": "notation.glob.js",
              "lineno": 57,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Checks whether the given notation value matches the source notation glob.",
            "name": "test",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "String"
                  ]
                },
                "description": "The notation string to be tested.",
                "name": "notation"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Boolean"
                  ]
                }
              }
            ],
            "examples": [
              "var glob = new Notation.Glob(\"!prop.*.name\");\n glob.test(\"prop.account.name\"); // true"
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob#test",
            "scope": "instance",
            "$longname": "Notation.Glob#test"
          },
          {
            "comment": "/**\n     *  Gets the union from the given couple of glob arrays and returns\n     *  a new array of globs. If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates. If one of the\n     *  arrays contains a negated equivalent of an item in the other array,\n     *  the negated item is removed. If any item covers/matches a negated\n     *  item in the other array, the negated item is removed.\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} arrA - First array of glob strings.\n     *  @param {Array} arrB - Second array of glob strings.\n     *  @param {Boolean} [sort=true] - Whether to sort the globs in the final\n     *  array.\n     *\n     *  @returns {Array}\n     *\n     *  @example\n     *  var a = [ 'foo.bar', 'bar.baz', '!*.qux' ],\n     *      b = [ '!foo.bar', 'bar.qux', 'bar.baz' ],\n     *  console.log(Notation.Glob.union(a, b));\n     *  // [ '!*.qux', 'foo.bar', 'bar.baz', 'bar.qux' ]\n     */",
            "meta": {
              "range": [
                8203,
                9185
              ],
              "filename": "notation.glob.js",
              "lineno": 231,
              "path": "/Users/oy/Developer/javascript/notation/src/core",
              "code": {}
            },
            "description": "Gets the union from the given couple of glob arrays and returns\n a new array of globs. If the exact same element is found in both\n arrays, one of them is removed to prevent duplicates. If one of the\n arrays contains a negated equivalent of an item in the other array,\n the negated item is removed. If any item covers/matches a negated\n item in the other array, the negated item is removed.",
            "name": "union",
            "kind": "function",
            "params": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "First array of glob strings.",
                "name": "arrA"
              },
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                },
                "description": "Second array of glob strings.",
                "name": "arrB"
              },
              {
                "type": {
                  "names": [
                    "Boolean"
                  ]
                },
                "optional": true,
                "defaultvalue": true,
                "description": "Whether to sort the globs in the final\n array.",
                "name": "sort"
              }
            ],
            "returns": [
              {
                "type": {
                  "names": [
                    "Array"
                  ]
                }
              }
            ],
            "examples": [
              "var a = [ 'foo.bar', 'bar.baz', '!*.qux' ],\n     b = [ '!foo.bar', 'bar.qux', 'bar.baz' ],\n console.log(Notation.Glob.union(a, b));\n // [ '!*.qux', 'foo.bar', 'bar.baz', 'bar.qux' ]"
            ],
            "memberof": "Notation.Glob",
            "longname": "Notation.Glob.union",
            "scope": "static",
            "$longname": "Notation.Glob.union"
          }
        ],
        "$constructor": {
          "comment": "/**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *\n     *  @param {String} glob - The glob string.\n     */",
          "meta": {
            "range": [
              1310,
              1725
            ],
            "filename": "notation.glob.js",
            "lineno": 41,
            "path": "/Users/oy/Developer/javascript/notation/src/core",
            "code": {
              "id": "astnode100000103",
              "name": "NotationGlob",
              "type": "MethodDefinition",
              "paramnames": [
                "glob"
              ]
            },
            "vars": {
              "": null
            }
          },
          "description": "Constructs a `Notation.Glob` object with the given glob string.",
          "alias": "Notation.Glob",
          "kind": "class",
          "params": [
            {
              "type": {
                "names": [
                  "String"
                ]
              },
              "description": "The glob string.",
              "name": "glob"
            }
          ],
          "name": "Glob",
          "longname": "Notation.Glob",
          "memberof": "Notation",
          "scope": "static",
          "$longname": "Notation.NotationGlob"
        }
      },
      {
        "comment": "/**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */",
        "meta": {
          "range": [
            11694,
            11758
          ],
          "filename": "notation.js",
          "lineno": 332,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001189",
            "name": "Notation#has",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Checks whether the source object has the given notation\n as a (leveled) enumerable property. If the property exists\n but has a value of `undefined`, this will still return `true`.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be checked.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Boolean"
              ]
            }
          }
        ],
        "examples": [
          "Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n Notation.create({}).has(\"car.color\"); // false"
        ],
        "name": "has",
        "longname": "Notation#has",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#has"
      },
      {
        "comment": "/**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */",
        "meta": {
          "range": [
            12350,
            12437
          ],
          "filename": "notation.js",
          "lineno": 350,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001202",
            "name": "Notation#hasDefined",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Checks whether the source object has the given notation\n as a (leveled) defined enumerable property. If the property\n exists but has a value of `undefined`, this will return `false`.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be checked.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Boolean"
              ]
            }
          }
        ],
        "examples": [
          "Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n Notation.create({}).hasDefined(\"car.color\"); // false"
        ],
        "name": "hasDefined",
        "longname": "Notation#hasDefined",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#hasDefined"
      },
      {
        "comment": "/**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970 }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined }\n     */",
        "meta": {
          "range": [
            8280,
            8943
          ],
          "filename": "notation.js",
          "lineno": 245,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000991",
            "name": "Notation#inspect",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Inspects the given notation on the source object by checking\n if the source object actually has the notated property;\n and getting its value if exists.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be inspected.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "InspectResult"
              ]
            },
            "description": "- The result object."
          }
        ],
        "examples": [
          "Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n // { has: true, value: 1970 }\n Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n // { has: false, value: undefined }\n Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n // { has: true, value: undefined }"
        ],
        "name": "inspect",
        "longname": "Notation#inspect",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#inspect"
      },
      {
        "comment": "/**\n     *  Inspects and removes the given notation from the source object\n     *  by checking if the source object actually has the notated property;\n     *  and getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  var obj = { name: \"John\", car: { year: 1970 } };\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\", car: {} }\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\" }\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n     *  // { has: true, value: undefined }\n     */",
        "meta": {
          "range": [
            10410,
            11127
          ],
          "filename": "notation.js",
          "lineno": 294,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001076",
            "name": "Notation#inspectRemove",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Inspects and removes the given notation from the source object\n by checking if the source object actually has the notated property;\n and getting its value if exists, before removing the property.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be inspected.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "InspectResult"
              ]
            },
            "description": "- The result object."
          }
        ],
        "examples": [
          "var obj = { name: \"John\", car: { year: 1970 } };\n Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n // obj » { name: \"John\", car: {} }\n Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n // obj » { name: \"John\" }\n Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n // { has: false, value: undefined }\n Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n // { has: true, value: undefined }"
        ],
        "name": "inspectRemove",
        "longname": "Notation#inspectRemove",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#inspectRemove"
      },
      {
        "comment": "/**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {Boolean} has - Indicates whether the source object has the given\n     *  notation as a (leveled) enumerable property. If the property exists but has\n     *  a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source object\n     *  does not have the notation, the value will be `undefined`.\n     */",
        "meta": {
          "range": [
            8948,
            9447
          ],
          "filename": "notation.js",
          "lineno": 263,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {}
        },
        "description": "Notation inspection result object.",
        "kind": "typedef",
        "name": "InspectResult",
        "type": {
          "names": [
            "Object"
          ]
        },
        "properties": [
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "description": "Indicates whether the source object has the given\n notation as a (leveled) enumerable property. If the property exists but has\n a value of `undefined`, this will still return `true`.",
            "name": "has"
          },
          {
            "type": {
              "names": [
                "*"
              ]
            },
            "description": "The value of the notated property. If the source object\n does not have the notation, the value will be `undefined`.",
            "name": "value"
          }
        ],
        "memberof": "Notation",
        "longname": "Notation~InspectResult",
        "scope": "inner",
        "$longname": "Notation~InspectResult"
      },
      {
        "comment": "/**\n     *  Checks whether the given notation string is valid.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('prop1'); // true\n     *  Notation.isValid(null); // false\n     */",
        "meta": {
          "range": [
            36034,
            36173
          ],
          "filename": "notation.js",
          "lineno": 930,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002080",
            "name": "Notation.isValid",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Checks whether the given notation string is valid.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be checked.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Boolean"
              ]
            }
          }
        ],
        "examples": [
          "Notation.isValid('prop1.prop2.prop3'); // true\n Notation.isValid('prop1'); // true\n Notation.isValid(null); // false"
        ],
        "name": "isValid",
        "longname": "Notation.isValid",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.isValid"
      },
      {
        "comment": "/**\n     *  Gets the last note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */",
        "meta": {
          "range": [
            36962,
            37226
          ],
          "filename": "notation.js",
          "lineno": 963,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002129",
            "name": "Notation.last",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the last note of the notation string.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be processed.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "String"
              ]
            }
          }
        ],
        "examples": [
          "Notation.last('first.prop2.last'); // \"last\""
        ],
        "name": "last",
        "longname": "Notation.last",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.last"
      },
      {
        "comment": "/**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(assets)\n     *      .merge({\n     *          \"car.brand\": \"Ford\",\n     *          \"car.model\": \"Mustang\",\n     *          \"car.year\": 1965,\n     *          \"car.color\": \"red\",\n     *          \"boat\": \"none\"\n     *      });\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */",
        "meta": {
          "range": [
            16846,
            17311
          ],
          "filename": "notation.js",
          "lineno": 459,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001340",
            "name": "Notation#merge",
            "type": "MethodDefinition",
            "paramnames": [
              "notationsObject",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Just like the `.set()` method but instead of a single notation\n string, an object of notations and values can be passed.\n Sets the value of each corresponding property at the given\n notation. If a property does not exist, it will be created\n and nested at the calculated level. If it exists; its value\n will be overwritten by default.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "The notations object to be processed.\n This can either be a regular object with non-dotted keys\n (which will be merged to the first/root level of the source object);\n or a flattened object with notated (dotted) keys.",
            "name": "notationsObject"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite a property if\n exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Dodge\", year: 1970 } };\n Notation.create(assets)\n     .merge({\n         \"car.brand\": \"Ford\",\n         \"car.model\": \"Mustang\",\n         \"car.year\": 1965,\n         \"car.color\": \"red\",\n         \"boat\": \"none\"\n     });\n console.log(assets);\n // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };"
        ],
        "name": "merge",
        "longname": "Notation#merge",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#merge"
      },
      {
        "comment": "/**\n     *  Removes the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the destination object.\n     *  @param {String} [newNotation=null] - The notation to set the destination\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */",
        "meta": {
          "range": [
            31102,
            31457
          ],
          "filename": "notation.js",
          "lineno": 787,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001911",
            "name": "Notation#moveFrom",
            "type": "MethodDefinition",
            "paramnames": [
              "destination",
              "notation",
              "newNotation",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Removes the notated property from the destination object and adds it to the\n source object — only if the destination object actually has that property.\n This is different than a property with a value of `undefined`.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "The destination object that the notated\n properties will be moved from.",
            "name": "destination"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding property\n from the destination object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "optional": true,
            "defaultvalue": null,
            "description": "The notation to set the destination\n property on the source object. In other words, the moved property\n will be renamed to this value before set on the source object.\n If not set, `notation` argument will be used.",
            "name": "newNotation"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property on\n the source object if it exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var models = { dodge: \"Charger\" };\n Notation.create(assets).moveFrom(models, \"dodge\", \"car.model\", true);\n console.log(assets);\n // { car: { brand: \"Ford\", model: \"Charger\" } }\n console.log(models);\n // {}"
        ],
        "name": "moveFrom",
        "longname": "Notation#moveFrom",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#moveFrom"
      },
      {
        "comment": "/**\n     *  Removes the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *  properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the moved property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */",
        "meta": {
          "range": [
            29401,
            29754
          ],
          "filename": "notation.js",
          "lineno": 750,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001857",
            "name": "Notation#moveTo",
            "type": "MethodDefinition",
            "paramnames": [
              "destination",
              "notation",
              "newNotation",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Removes the notated property from the source object and adds it to the\n destination — only if the source object actually has that property.\n This is different than a property with a value of `undefined`.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "The destination object that the notated\n properties will be moved to.",
            "name": "destination"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding\n property from the source object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "optional": true,
            "defaultvalue": null,
            "description": "The notation to set the source property\n on the destination object. In other words, the moved property will be\n renamed to this value before set on the destination object. If not set,\n `notation` argument will be used.",
            "name": "newNotation"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property on\n the destination object if it exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n var models = { dodge: \"Charger\" };\n Notation.create(assets).moveTo(models, \"car.model\", \"ford\");\n console.log(assets);\n // { car: { brand: \"Ford\" } }\n console.log(models);\n // { dodge: \"Charger\", ford: \"Mustang\" }"
        ],
        "name": "moveTo",
        "longname": "Notation#moveTo",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#moveTo"
      },
      {
        "comment": "/**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @returns {String}\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */",
        "meta": {
          "range": [
            37592,
            37860
          ],
          "filename": "notation.js",
          "lineno": 983,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100002165",
            "name": "Notation.parent",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the parent notation (up to but excluding the last note)\n from the notation string.",
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be processed.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "String"
              ]
            }
          }
        ],
        "examples": [
          "Notation.parent('first.prop2.last'); // \"first.prop2\"\n Notation.parent('single'); // null"
        ],
        "name": "parent",
        "longname": "Notation.parent",
        "kind": "function",
        "memberof": "Notation",
        "scope": "static",
        "$longname": "Notation.parent"
      },
      {
        "comment": "/**\n     *  Removes the property at the given notation, from the source object.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to be inspected.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(assets).remove(\"car.model\");\n     *  console.log(assets); // { notebook: \"Mac\", car: { } }\n     */",
        "meta": {
          "range": [
            24313,
            24396
          ],
          "filename": "notation.js",
          "lineno": 634,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001718",
            "name": "Notation#remove",
            "type": "MethodDefinition",
            "paramnames": [
              "notation"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Removes the property at the given notation, from the source object.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to be inspected.",
            "name": "notation"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n Notation.create(assets).remove(\"car.model\");\n console.log(assets); // { notebook: \"Mac\", car: { } }"
        ],
        "name": "remove",
        "longname": "Notation#remove",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#remove"
      },
      {
        "comment": "/**\n     *  Renames the notated property of the source object by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source object will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(assets)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(assets);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */",
        "meta": {
          "range": [
            32387,
            32550
          ],
          "filename": "notation.js",
          "lineno": 818,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001965",
            "name": "Notation#rename",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "newNotation",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Renames the notated property of the source object by the new notation.",
        "alias": "Notation#renote",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation to get the corresponding\n property (value) from the source object.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The new notation for the targeted\n property value. If not set, the source object will not be modified.",
            "name": "newNotation"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property at\n the new notation, if it exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n Notation.create(assets)\n     .rename(\"car.brand\", \"carBrand\")\n     .rename(\"car.model\", \"carModel\");\n console.log(assets);\n // { carBrand: \"Ford\", carModel: \"Mustang\" }"
        ],
        "name": "renote",
        "longname": "Notation#renote",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#rename"
      },
      {
        "comment": "/**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  var separated = Notation.create(assets).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(assets);\n     *  // { car: { year: 1970 } };\n     */",
        "meta": {
          "range": [
            18009,
            18419
          ],
          "filename": "notation.js",
          "lineno": 489,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001402",
            "name": "Notation#separate",
            "type": "MethodDefinition",
            "paramnames": [
              "notations"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Removes the properties by the given list of notations from the source\n object and returns a new object with the removed properties.\n Opposite of `merge()` method.",
        "params": [
          {
            "type": {
              "names": [
                "Array"
              ]
            },
            "description": "The notations array to be processed.",
            "name": "notations"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Object"
              ]
            },
            "description": "- An object with the removed properties."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n var separated = Notation.create(assets).separate([\"car.brand\", \"boat\" ]);\n console.log(separated);\n // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n console.log(assets);\n // { car: { year: 1970 } };"
        ],
        "name": "separate",
        "longname": "Notation#separate",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#separate"
      },
      {
        "comment": "/**\n     *  Sets the value of the corresponding property at the given\n     *  notation. If the property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\n     *  if exists.\n     *\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(assets)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(assets);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */",
        "meta": {
          "range": [
            14381,
            15501
          ],
          "filename": "notation.js",
          "lineno": 400,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100001241",
            "name": "Notation#set",
            "type": "MethodDefinition",
            "paramnames": [
              "notation",
              "value",
              "overwrite"
            ]
          },
          "vars": {
            "": null
          }
        },
        "description": "Sets the value of the corresponding property at the given\n notation. If the property does not exist, it will be created\n and nested at the calculated level. If it exists; its value\n will be overwritten by default.",
        "tags": [
          {
            "originalTitle": "chainable",
            "title": "chainable",
            "text": ""
          }
        ],
        "params": [
          {
            "type": {
              "names": [
                "String"
              ]
            },
            "description": "The notation string to be processed.",
            "name": "notation"
          },
          {
            "type": {
              "names": [
                "*"
              ]
            },
            "description": "The value to be set for the notated property.",
            "name": "value"
          },
          {
            "type": {
              "names": [
                "Boolean"
              ]
            },
            "optional": true,
            "defaultvalue": true,
            "description": "Whether to overwrite the property\n if exists.",
            "name": "overwrite"
          }
        ],
        "returns": [
          {
            "type": {
              "names": [
                "Notation"
              ]
            },
            "description": "- Returns the current `Notation` instance (self)."
          }
        ],
        "examples": [
          "var assets = { car: { brand: \"Dodge\", year: 1970 } };\n Notation.create(assets)\n     .set(\"car.brand\", \"Ford\")\n     .set(\"car.model\", \"Mustang\")\n     .set(\"car.year\", 1965, false)\n     .set(\"car.color\", \"red\")\n     .set(\"boat\", \"none\");\n console.log(assets);\n // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };"
        ],
        "name": "set",
        "longname": "Notation#set",
        "kind": "function",
        "memberof": "Notation",
        "scope": "instance",
        "$longname": "Notation#set"
      },
      {
        "comment": "/**\n     *  Gets the value of the source object.\n     *  @type {Object}\n     *\n     *  @example\n     *  var person = { name: \"Onur\" };\n     *  var me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me);\n     *  // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me);\n     *  // true\n     */",
        "meta": {
          "range": [
            2462,
            2510
          ],
          "filename": "notation.js",
          "lineno": 77,
          "path": "/Users/oy/Developer/javascript/notation/src/core",
          "code": {
            "id": "astnode100000719",
            "name": "Notation#value",
            "type": "MethodDefinition",
            "paramnames": []
          },
          "vars": {
            "": null
          }
        },
        "description": "Gets the value of the source object.",
        "type": {
          "names": [
            "Object"
          ]
        },
        "examples": [
          "var person = { name: \"Onur\" };\n var me = Notation.create(person)\n     .set(\"age\", 36)\n     .set(\"car.brand\", \"Ford\")\n     .set(\"car.model\", \"Mustang\")\n     .value;\n console.log(me);\n // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n console.log(person === me);\n // true"
        ],
        "name": "value",
        "longname": "Notation#value",
        "kind": "member",
        "memberof": "Notation",
        "scope": "instance",
        "params": [],
        "$longname": "Notation#value"
      }
    ],
    "$constructor": {
      "comment": "/**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object} [object={}] - The source object to be notated.\n     *\n     *  @example\n     *  var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var nota = new Notation(carInfo);\n     *  nota.get('car.model'); // \"Charger\"\n     */",
      "meta": {
        "range": [
          1660,
          1868
        ],
        "filename": "notation.js",
        "lineno": 49,
        "path": "/Users/oy/Developer/javascript/notation/src/core",
        "code": {
          "id": "astnode100000692",
          "name": "Notation",
          "type": "MethodDefinition",
          "paramnames": [
            "object"
          ]
        },
        "vars": {
          "": null
        }
      },
      "description": "Initializes a new instance of `Notation`.",
      "params": [
        {
          "type": {
            "names": [
              "Object"
            ]
          },
          "optional": true,
          "defaultvalue": "{}",
          "description": "The source object to be notated.",
          "name": "object"
        }
      ],
      "examples": [
        "var carInfo = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n var nota = new Notation(carInfo);\n nota.get('car.model'); // \"Charger\""
      ],
      "name": "Notation",
      "longname": "Notation",
      "kind": "class",
      "scope": "global",
      "undocumented": true,
      "$longname": "Notation"
    }
  },
  {
    "comment": "/**\n     *  Initializes a new `NotationError` instance.\n     *  @param {String} message - The error message.\n     */",
    "meta": {
      "range": [
        309,
        1048
      ],
      "filename": "notation.error.js",
      "lineno": 17,
      "path": "/Users/oy/Developer/javascript/notation/src/core",
      "code": {
        "id": "astnode100000005",
        "name": "NotationError",
        "type": "MethodDefinition",
        "paramnames": [
          "message"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Initializes a new `NotationError` instance.",
    "params": [
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "description": "The error message.",
        "name": "message"
      }
    ],
    "name": "NotationError",
    "longname": "NotationError",
    "kind": "class",
    "scope": "global",
    "$longname": "NotationError"
  }
]