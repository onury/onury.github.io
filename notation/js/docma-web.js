/*! dustjs-linkedin - v2.7.5
* http://dustjs.com/
* Copyright (c) 2016 Aleksander Williams; Released under the MIT License */
!function(a,b){"function"==typeof define&&define.amd&&define.amd.dust===!0?define("dust.core",[],b):"object"==typeof exports?module.exports=b():a.dust=b()}(this,function(){function getTemplate(a,b){return a?"function"==typeof a&&a.template?a.template:dust.isTemplateFn(a)?a:b!==!1?dust.cache[a]:void 0:void 0}function load(a,b,c){if(!a)return b.setError(new Error("No template or template name provided to render"));var d=getTemplate(a,dust.config.cache);return d?d(b,Context.wrap(c,d.templateName)):dust.onLoad?b.map(function(b){function d(a,d){var f;if(a)return b.setError(a);if(f=getTemplate(d,!1)||getTemplate(e,dust.config.cache),!f){if(!dust.compile)return b.setError(new Error("Dust compiler not available"));f=dust.loadSource(dust.compile(d,e))}f(b,Context.wrap(c,f.templateName)).end()}var e=a;3===dust.onLoad.length?dust.onLoad(e,c.options,d):dust.onLoad(e,d)}):b.setError(new Error("Template Not Found: "+a))}function Context(a,b,c,d,e){void 0===a||a instanceof Stack||(a=new Stack(a)),this.stack=a,this.global=b,this.options=c,this.blocks=d,this.templateName=e,this._isContext=!0}function getWithResolvedData(a,b,c){return function(d){return a.push(d)._get(b,c)}}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&"object"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=""}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function Tap(a,b){this.head=a,this.tail=b}var dust={version:"2.7.5"},NONE="NONE",ERROR="ERROR",WARN="WARN",INFO="INFO",DEBUG="DEBUG",EMPTY_FUNC=function(){};dust.config={whitespace:!1,amd:!1,cjs:!1,cache:!0},dust._aliases={write:"w",end:"e",map:"m",render:"r",reference:"f",section:"s",exists:"x",notexists:"nx",block:"b",partial:"p",helper:"h"},function(){var a,b,c={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};"undefined"!=typeof console&&console.log?(a=console.log,b="function"==typeof a?function(){a.apply(console,arguments)}:function(){a(Array.prototype.slice.apply(arguments).join(" "))}):b=EMPTY_FUNC,dust.log=function(a,d){d=d||INFO,c[d]>=c[dust.debugLevel]&&b("[DUST:"+d+"]",a)},dust.debugLevel=NONE,"undefined"!=typeof process&&process.env&&/\bdust\b/.test(process.env.DEBUG)&&(dust.debugLevel=DEBUG)}(),dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(b.templateName=a,dust.config.cache!==!1&&(dust.cache[a]=b))},dust.render=function(a,b,c){var d=new Stub(c).head;try{load(a,d,b).end()}catch(e){d.setError(e)}},dust.stream=function(a,b){var c=new Stream,d=c.head;return dust.nextTick(function(){try{load(a,d,b).end()}catch(c){d.setError(c)}}),c},dust.loadSource=function(source){return eval(source)},dust.isArray=Array.isArray?Array.isArray:function(a){return"[object Array]"===Object.prototype.toString.call(a)},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return 0===a?!1:dust.isArray(a)&&!a.length?!0:!a},dust.isEmptyObject=function(a){var b;if(null===a)return!1;if(void 0===a)return!1;if(a.length>0)return!1;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b))return!1;return!0},dust.isTemplateFn=function(a){return"function"==typeof a&&a.__dustBody},dust.isThenable=function(a){return a&&"object"==typeof a&&"function"==typeof a.then},dust.isStreamable=function(a){return a&&"function"==typeof a.on&&"function"==typeof a.pipe},dust.filter=function(a,b,c,d){var e,f,g,h;if(c)for(e=0,f=c.length;f>e;e++)g=c[e],g.length&&(h=dust.filters[g],"s"===g?b=null:"function"==typeof h?a=h(a,d):dust.log("Invalid filter `"+g+"`",WARN));return b&&(a=dust.filters[b](a,d)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return dust.escapeJSON(a)},jp:function(a){return JSON?JSON.parse(a):(dust.log("JSON is undefined; could not parse `"+a+"`",WARN),a)}},dust.makeBase=dust.context=function(a,b){return new Context(void 0,a,b)},dust.isContext=function(a){return"object"==typeof a&&a._isContext===!0},Context.wrap=function(a,b){return dust.isContext(a)?a:new Context(a,{},{},null,b)},Context.prototype.get=function(a,b){return"string"==typeof a&&("."===a[0]&&(b=!0,a=a.substr(1)),a=a.split(".")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g,h=this.stack||{},i=1;if(d=b[0],e=b.length,a&&0===e)f=h,h=h.head;else{if(a)h&&(h=h.head?h.head[d]:void 0);else{for(;h&&(!h.isObject||(f=h.head,c=h.head[d],void 0===c));)h=h.tail;h=void 0!==c?c:this.global&&this.global[d]}for(;h&&e>i;){if(dust.isThenable(h))return h.then(getWithResolvedData(this,a,b.slice(i)));f=h,h=h[b[i]],i++}}return"function"==typeof h?(g=function(){try{return h.apply(f,arguments)}catch(a){throw dust.log(a,ERROR),a}},g.__dustBody=!!h.__dustBody,g):(void 0===h&&dust.log("Cannot find reference `{"+b.join(".")+"}` in template `"+this.getTemplateName()+"`",INFO),h)},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return void 0===a?(dust.log("Not pushing an undefined variable onto the context",INFO),this):this.rebase(new Stack(a,this.stack,b,c))},Context.prototype.pop=function(){var a=this.current();return this.stack=this.stack&&this.stack.tail,a},Context.prototype.rebase=function(a){return new Context(a,this.global,this.options,this.blocks,this.getTemplateName())},Context.prototype.clone=function(){var a=this.rebase();return a.stack=this.stack,a},Context.prototype.current=function(){return this.stack&&this.stack.head},Context.prototype.getBlock=function(a){var b,c,d;if("function"==typeof a&&(a=a(new Chunk,this).data.join("")),b=this.blocks,!b)return dust.log("No blocks for context `"+a+"` in template `"+this.getTemplateName()+"`",DEBUG),!1;for(c=b.length;c--;)if(d=b[c][a])return d;return dust.log("Malformed template `"+this.getTemplateName()+"` was missing one or more blocks."),!1},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,this.options,b,this.getTemplateName())):this},Context.prototype.resolve=function(a){var b;return"function"!=typeof a?a:(b=(new Chunk).render(a,this),b instanceof Chunk?b.data.join(""):b)},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log("Rendering failed with error `"+a.error+"`",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(""),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit("error",a.error),this.emit("end"),dust.log("Streaming failed with error `"+a.error+"`",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.emit("data",a.data.join("")),a=a.next,this.head=a}this.emit("end")},Stream.prototype.emit=function(a,b){var c,d,e=this.events||{},f=e[a]||[];if(!f.length)return dust.log("Stream broadcasting, but no listeners for `"+a+"`",DEBUG),!1;for(f=f.slice(0),c=0,d=f.length;d>c;c++)f[c](b);return!0},Stream.prototype.on=function(a,b){var c=this.events=this.events||{},d=c[a]=c[a]||[];return"function"!=typeof b?dust.log("No callback function provided for `"+a+"` event listener",WARN):d.push(b),this},Stream.prototype.pipe=function(a){if("function"!=typeof a.write||"function"!=typeof a.end)return dust.log("Incompatible stream passed to `pipe`",WARN),this;var b=!1;return"function"==typeof a.emit&&a.emit("pipe",this),"function"==typeof a.on&&a.on("error",function(){b=!0}),this.on("data",function(c){if(!b)try{a.write(c,"utf8")}catch(d){dust.log(d,ERROR)}}).on("end",function(){if(!b)try{a.end(),b=!0}catch(c){dust.log(c,ERROR)}})},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);this.next=c,this.flushable=!0;try{a(c)}catch(d){dust.log(d,ERROR),c.setError(d)}return b},Chunk.prototype.tap=function(a){var b=this.taps;return this.taps=b?b.push(a):new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return"function"==typeof a?(a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk?a:this.reference(a,b,c,d)):dust.isThenable(a)?this.await(a,b,null,c,d):dust.isStreamable(a)?this.stream(a,b,null,c,d):dust.isEmpty(a)?this:this.write(dust.filter(a,c,d,b))},Chunk.prototype.section=function(a,b,c,d){var e,f,g,h=c.block,i=c["else"],j=this;if("function"==typeof a&&!dust.isTemplateFn(a)){try{a=a.apply(b.current(),[this,b,c,d])}catch(k){return dust.log(k,ERROR),this.setError(k)}if(a instanceof Chunk)return a}if(dust.isEmptyObject(c))return j;if(dust.isEmptyObject(d)||(b=b.push(d)),dust.isArray(a)){if(h){if(f=a.length,f>0){for(g=b.stack&&b.stack.head||{},g.$len=f,e=0;f>e;e++)g.$idx=e,j=h(j,b.push(a[e],e,f));return g.$idx=void 0,g.$len=void 0,j}if(i)return i(this,b)}}else{if(dust.isThenable(a))return this.await(a,b,c);if(dust.isStreamable(a))return this.stream(a,b,c);if(a===!0){if(h)return h(this,b)}else if(a||0===a){if(h)return h(this,b.push(a))}else if(i)return i(this,b)}return dust.log("Section without corresponding key in template `"+b.getTemplateName()+"`",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c["else"];if(dust.isEmpty(a)){if(e)return e(this,b)}else{if(d)return d(this,b);dust.log("No block for exists check in template `"+b.getTemplateName()+"`",DEBUG)}return this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c["else"];if(dust.isEmpty(a)){if(d)return d(this,b);dust.log("No block for not-exists check in template `"+b.getTemplateName()+"`",DEBUG)}else if(e)return e(this,b);return this},Chunk.prototype.block=function(a,b,c){var d=a||c.block;return d?d(this,b):this},Chunk.prototype.partial=function(a,b,c,d){var e;return void 0===d&&(d=c,c=b),dust.isEmptyObject(d)||(c=c.clone(),e=c.pop(),c=c.push(d).push(e)),dust.isTemplateFn(a)?this.capture(a,b,function(a,b){c.templateName=a,load(a,b,c).end()}):(c.templateName=a,load(a,this,c))},Chunk.prototype.helper=function(a,b,c,d,e){var f,g=this,h=d.filters;if(void 0===e&&(e="h"),!dust.helpers[a])return dust.log("Helper `"+a+"` does not exist",WARN),g;try{return f=dust.helpers[a](g,b,c,d),f instanceof Chunk?f:("string"==typeof h&&(h=h.split("|")),dust.isEmptyObject(c)?g.reference(f,b,e,h):g.section(f,b,c,d))}catch(i){return dust.log("Error in helper `"+a+"`: "+i.message,ERROR),g.setError(i)}},Chunk.prototype.await=function(a,b,c,d,e){return this.map(function(f){a.then(function(a){f=c?f.section(a,b,c):f.reference(a,b,d,e),f.end()},function(a){var d=c&&c.error;d?f.render(d,b.push(a)).end():(dust.log("Unhandled promise rejection in `"+b.getTemplateName()+"`",INFO),f.end())})})},Chunk.prototype.stream=function(a,b,c,d,e){var f=c&&c.block,g=c&&c.error;return this.map(function(h){var i=!1;a.on("data",function(a){i||(f?h=h.map(function(c){c.render(f,b.push(a)).end()}):c||(h=h.reference(a,b,d,e)))}).on("error",function(a){i||(g?h.render(g,b.push(a)):dust.log("Unhandled stream error in `"+b.getTemplateName()+"`",INFO),i||(i=!0,h.end()))}).on("end",function(){i||(i=!0,h.end())})})},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this};for(var f in Chunk.prototype)dust._aliases[f]&&(Chunk.prototype[dust._aliases[f]]=Chunk.prototype[f]);Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=/[&<>"']/,AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\"/g,SQUOT=/\'/g;dust.escapeHtml=function(a){return"string"==typeof a||a&&"function"==typeof a.toString?("string"!=typeof a&&(a=a.toString()),HCHARS.test(a)?a.replace(AMP,"&amp;").replace(LT,"&lt;").replace(GT,"&gt;").replace(QUOT,"&quot;").replace(SQUOT,"&#39;"):a):a};var BS=/\\/g,FS=/\//g,CR=/\r/g,LS=/\u2028/g,PS=/\u2029/g,NL=/\n/g,LF=/\f/g,SQ=/'/g,DQ=/"/g,TB=/\t/g;return dust.escapeJs=function(a){return"string"==typeof a?a.replace(BS,"\\\\").replace(FS,"\\/").replace(DQ,'\\"').replace(SQ,"\\'").replace(CR,"\\r").replace(LS,"\\u2028").replace(PS,"\\u2029").replace(NL,"\\n").replace(LF,"\\f").replace(TB,"\\t"):a},dust.escapeJSON=function(a){return JSON?JSON.stringify(a).replace(LS,"\\u2028").replace(PS,"\\u2029").replace(LT,"\\u003c"):(dust.log("JSON is undefined; could not escape `"+a+"`",WARN),a)},dust}),"function"==typeof define&&define.amd&&define.amd.dust===!0&&define(["require","dust.core"],function(require,dust){return dust.onLoad=function(a,b){require([a],function(){b()})},dust});
/*! dustjs-helpers - v1.7.4
* http://dustjs.com/
* Copyright (c) 2017 Aleksander Williams; Released under the MIT License */
!function(a,b){"function"==typeof define&&define.amd&&define.amd.dust===!0?define(["dust.core"],b):"object"==typeof exports?(module.exports=b(require("dustjs-linkedin")),module.exports.registerWith=b):b(a.dust)}(this,function(dust){function a(a,b,c){c=c||"INFO",a=a?"{@"+a+"}: ":"",dust.log(a+b,c)}function b(b){k[b]||(a(b,"Deprecation warning: "+b+" is deprecated and will be removed in a future version of dustjs-helpers","WARN"),a(null,"For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#"+b.replace(/\W+/g,""),"WARN"),k[b]=!0)}function c(a){return a.stack.tail&&a.stack.tail.head&&"undefined"!=typeof a.stack.tail.head.__select__}function d(a){return c(a)&&a.get("__select__")}function e(a,b){var c,d=a.stack.head,e=a.rebase();a.stack&&a.stack.tail&&(e.stack=a.stack.tail);var f={isPending:!1,isResolved:!1,isDeferredComplete:!1,deferreds:[]};for(c in b)f[c]=b[c];return e.push({__select__:f}).push(d,a.stack.index,a.stack.of)}function f(a){var b,c;if(a.isDeferredPending=!0,a.deferreds.length)for(a.isDeferredComplete=!0,b=0,c=a.deferreds.length;c>b;b++)a.deferreds[b]();a.isDeferredPending=!1}function g(a,b){return"function"==typeof b?b.toString().replace(/(^\s+|\s+$)/gm,"").replace(/\n/gm,"").replace(/,\s*/gm,", ").replace(/\)\{/gm,") {"):b}function h(a,b){return function(c,d,e,f){return i(c,d,e,f,a,b)}}function i(b,c,e,f,g,h){var i,k,l,m,n=e.block,o=e["else"],p=d(c)||{};if(p.isResolved&&!p.isDeferredPending)return b;if(f.hasOwnProperty("key"))k=f.key;else{if(!p.hasOwnProperty("key"))return a(g,"No key specified","WARN"),b;k=p.key}return m=f.type||p.type,k=j(c.resolve(k),m),l=j(c.resolve(f.value),m),h(k,l)?(p.isPending||(i=!0,p.isPending=!0),n&&(b=b.render(n,c)),i&&(p.isResolved=!0)):o&&(b=b.render(o,c)),b}function j(a,b){switch(b&&(b=b.toLowerCase()),b){case"number":return+a;case"string":return String(a);case"boolean":return a="false"===a?!1:a,Boolean(a);case"date":return new Date(a)}return a}var k={},l={tap:function(a,c,d){return b("tap"),d.resolve(a)},sep:function(a,b,c){var d=c.block;return b.stack.index===b.stack.of-1?a:d?d(a,b):a},first:function(a,b,c){return 0===b.stack.index?c.block(a,b):a},last:function(a,b,c){return b.stack.index===b.stack.of-1?c.block(a,b):a},contextDump:function(b,c,d,e){var f,h,i=c.resolve(e.to),j=c.resolve(e.key);switch(j){case"full":f=c.stack;break;default:f=c.stack.head}switch(h=JSON.stringify(f,g,2),i){case"console":a("contextDump",h);break;default:h=h.replace(/</g,"\\u003c"),b=b.write(h)}return b},math:function(b,c,g,h){var i,j=h.key,k=h.method,l=h.operand,m=h.round;if(!h.hasOwnProperty("key")||!h.method)return a("math","`key` or `method` was not provided","ERROR"),b;switch(j=parseFloat(c.resolve(j)),l=parseFloat(c.resolve(l)),k){case"mod":0===l&&a("math","Division by 0","ERROR"),i=j%l;break;case"add":i=j+l;break;case"subtract":i=j-l;break;case"multiply":i=j*l;break;case"divide":0===l&&a("math","Division by 0","ERROR"),i=j/l;break;case"ceil":case"floor":case"round":case"abs":i=Math[k](j);break;case"toint":i=parseInt(j,10);break;default:a("math","Method `"+k+"` is not supported","ERROR")}return"undefined"!=typeof i&&(m&&(i=Math.round(i)),g&&g.block?(c=e(c,{key:i}),b=b.render(g.block,c),f(d(c))):b=b.write(i)),b},select:function(b,c,g,h){var i=g.block,j={};return h.hasOwnProperty("key")&&(j.key=c.resolve(h.key)),h.hasOwnProperty("type")&&(j.type=h.type),i?(c=e(c,j),b=b.render(i,c),f(d(c))):a("select","Missing body block","WARN"),b},eq:h("eq",function(a,b){return a===b}),ne:h("ne",function(a,b){return a!==b}),lt:h("lt",function(a,b){return b>a}),lte:h("lte",function(a,b){return b>=a}),gt:h("gt",function(a,b){return a>b}),gte:h("gte",function(a,b){return a>=b}),any:function(b,c,e){var f=d(c);return f?f.isDeferredComplete?a("any","Must not be nested inside {@any} or {@none} block","ERROR"):b=b.map(function(a){f.deferreds.push(function(){f.isResolved&&(a=a.render(e.block,c)),a.end()})}):a("any","Must be used inside a {@select} block","ERROR"),b},none:function(b,c,e){var f=d(c);return f?f.isDeferredComplete?a("none","Must not be nested inside {@any} or {@none} block","ERROR"):b=b.map(function(a){f.deferreds.push(function(){f.isResolved||(a=a.render(e.block,c)),a.end()})}):a("none","Must be used inside a {@select} block","ERROR"),b},size:function(a,b,c,d){var e,f,g=d.key;if(g=b.resolve(d.key),g&&g!==!0)if(dust.isArray(g))e=g.length;else if(!isNaN(parseFloat(g))&&isFinite(g))e=g;else if("object"==typeof g){e=0;for(f in g)g.hasOwnProperty(f)&&e++}else e=(g+"").length;else e=0;return a.write(e)}};for(var m in l)dust.helpers[m]=l[m];return dust});
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.page=e()}(this,function(){"use strict";function t(t){return r(a(t))}var p=Array.isArray||function(t){return"[object Array]"==Object.prototype.toString.call(t)},o=c,e=a,n=r,i=h,_=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function a(t){for(var e,n,i=[],o=0,r=0,a="";null!=(e=_.exec(t));){var s=e[0],h=e[1],c=e.index;if(a+=t.slice(r,c),r=c+s.length,h)a+=h[1];else{a&&(i.push(a),a="");var p=e[2],u=e[3],f=e[4],l=e[5],d=e[6],g=e[7],v="+"===d||"*"===d,m="?"===d||"*"===d,w=p||"/",y=f||l||(g?".*":"[^"+w+"]+?");i.push({name:u||o++,prefix:p||"",delimiter:w,optional:m,repeat:v,pattern:(n=y,n.replace(/([=!:$\/()])/g,"\\$1"))})}}return r<t.length&&(a+=t.substr(r)),a&&i.push(a),i}function r(h){for(var c=new Array(h.length),t=0;t<h.length;t++)"object"==typeof h[t]&&(c[t]=new RegExp("^"+h[t].pattern+"$"));return function(t){for(var e="",n=t||{},i=0;i<h.length;i++){var o=h[i];if("string"!=typeof o){var r,a=n[o.name];if(null==a){if(o.optional)continue;throw new TypeError('Expected "'+o.name+'" to be defined')}if(p(a)){if(!o.repeat)throw new TypeError('Expected "'+o.name+'" to not repeat, but received "'+a+'"');if(0===a.length){if(o.optional)continue;throw new TypeError('Expected "'+o.name+'" to not be empty')}for(var s=0;s<a.length;s++){if(r=encodeURIComponent(a[s]),!c[i].test(r))throw new TypeError('Expected all "'+o.name+'" to match "'+o.pattern+'", but received "'+r+'"');e+=(0===s?o.prefix:o.delimiter)+r}}else{if(r=encodeURIComponent(a),!c[i].test(r))throw new TypeError('Expected "'+o.name+'" to match "'+o.pattern+'", but received "'+r+'"');e+=o.prefix+r}}else e+=o}return e}}function u(t){return t.replace(/([.+*?=^!:${}()[\]|\/])/g,"\\$1")}function s(t,e){return t.keys=e,t}function f(t){return t.sensitive?"":"i"}function h(t,e){for(var n=(e=e||{}).strict,i=!1!==e.end,o="",r=t[t.length-1],a="string"==typeof r&&/\/$/.test(r),s=0;s<t.length;s++){var h=t[s];if("string"==typeof h)o+=u(h);else{var c=u(h.prefix),p=h.pattern;h.repeat&&(p+="(?:"+c+p+")*"),o+=p=h.optional?c?"(?:"+c+"("+p+"))?":"("+p+")?":c+"("+p+")"}}return n||(o=(a?o.slice(0,-2):o)+"(?:\\/(?=$))?"),o+=i?"$":n&&a?"":"(?=\\/|$)",new RegExp("^"+o,f(e))}function c(t,e,n){return p(e=e||[])?n=n||{}:(n=e,e=[]),t instanceof RegExp?function(t,e){var n=t.source.match(/\((?!\?)/g);if(n)for(var i=0;i<n.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,pattern:null});return s(t,e)}(t,e):p(t)?function(t,e,n){for(var i=[],o=0;o<t.length;o++)i.push(c(t[o],e,n).source);return s(new RegExp("(?:"+i.join("|")+")",f(n)),e)}(t,e,n):function(t,e,n){for(var i=a(t),o=h(i,n),r=0;r<i.length;r++)"string"!=typeof i[r]&&e.push(i[r]);return s(o,e)}(t,e,n)}o.parse=e,o.compile=t,o.tokensToFunction=n,o.tokensToRegExp=i;var l,d="undefined"!=typeof document,g="undefined"!=typeof window,v="undefined"!=typeof history,m="undefined"!=typeof process,w=d&&document.ontouchstart?"touchstart":"click",y=g&&!(!window.history.location&&!window.location);function b(){this.callbacks=[],this.exits=[],this.current="",this.len=0,this._decodeURLComponents=!0,this._base="",this._strict=!1,this._running=!1,this._hashbang=!1,this.clickHandler=this.clickHandler.bind(this),this._onpopstate=this._onpopstate.bind(this)}function x(t,e){if("function"==typeof t)return x.call(this,"*",t);if("function"==typeof e)for(var n=new R(t,null,this),i=1;i<arguments.length;++i)this.callbacks.push(n.middleware(arguments[i]));else"string"==typeof t?this["string"==typeof e?"redirect":"show"](t,e):this.start(t)}function E(t,e,n){var i=this.page=n||x,o=i._window,r=i._hashbang,a=i._getBase();"/"===t[0]&&0!==t.indexOf(a)&&(t=a+(r?"#!":"")+t);var s=t.indexOf("?");this.canonicalPath=t;var h=new RegExp("^"+function(t){return t.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}(a));if(this.path=t.replace(h,"")||"/",r&&(this.path=this.path.replace("#!","")||"/"),this.title=d&&o.document.title,this.state=e||{},this.state.path=t,this.querystring=~s?i._decodeURLEncodedURIComponent(t.slice(s+1)):"",this.pathname=i._decodeURLEncodedURIComponent(~s?t.slice(0,s):t),this.params={},this.hash="",!r){if(!~this.path.indexOf("#"))return;var c=this.path.split("#");this.path=this.pathname=c[0],this.hash=i._decodeURLEncodedURIComponent(c[1])||"",this.querystring=this.querystring.split("#")[0]}}function R(t,e,n){this.page=n||k;var i=e||{};i.strict=i.strict||n._strict,this.path="*"===t?"(.*)":t,this.method="GET",this.regexp=o(this.path,this.keys=[],i)}b.prototype.configure=function(t){var e=t||{};this._window=e.window||g&&window,this._decodeURLComponents=!1!==e.decodeURLComponents,this._popstate=!1!==e.popstate&&g,this._click=!1!==e.click&&d,this._hashbang=!!e.hashbang;var n=this._window;this._popstate?n.addEventListener("popstate",this._onpopstate,!1):g&&n.removeEventListener("popstate",this._onpopstate,!1),this._click?n.document.addEventListener(w,this.clickHandler,!1):d&&n.document.removeEventListener(w,this.clickHandler,!1),this._hashbang&&g&&!v?n.addEventListener("hashchange",this._onpopstate,!1):g&&n.removeEventListener("hashchange",this._onpopstate,!1)},b.prototype.base=function(t){if(0===arguments.length)return this._base;this._base=t},b.prototype._getBase=function(){var t=this._base;if(t)return t;var e=g&&this._window&&this._window.location;return g&&this._hashbang&&e&&"file:"===e.protocol&&(t=e.pathname),t},b.prototype.strict=function(t){if(0===arguments.length)return this._strict;this._strict=t},b.prototype.start=function(t){var e=t||{};if(this.configure(e),!1!==e.dispatch){var n;if(this._running=!0,y){var i=this._window.location;n=this._hashbang&&~i.hash.indexOf("#!")?i.hash.substr(2)+i.search:this._hashbang?i.search+i.hash:i.pathname+i.search+i.hash}this.replace(n,null,!0,e.dispatch)}},b.prototype.stop=function(){if(this._running){this.current="",this.len=0,this._running=!1;var t=this._window;this._click&&t.document.removeEventListener(w,this.clickHandler,!1),g&&t.removeEventListener("popstate",this._onpopstate,!1),g&&t.removeEventListener("hashchange",this._onpopstate,!1)}},b.prototype.show=function(t,e,n,i){var o=new E(t,e,this),r=this.prevContext;return this.prevContext=o,this.current=o.path,!1!==n&&this.dispatch(o,r),!1!==o.handled&&!1!==i&&o.pushState(),o},b.prototype.back=function(t,e){var n=this;if(0<this.len){var i=this._window;v&&i.history.back(),this.len--}else t?setTimeout(function(){n.show(t,e)}):setTimeout(function(){n.show(n._getBase(),e)})},b.prototype.redirect=function(t,e){var n=this;"string"==typeof t&&"string"==typeof e&&x.call(this,t,function(t){setTimeout(function(){n.replace(e)},0)}),"string"==typeof t&&void 0===e&&setTimeout(function(){n.replace(t)},0)},b.prototype.replace=function(t,e,n,i){var o=new E(t,e,this),r=this.prevContext;return this.prevContext=o,this.current=o.path,o.init=n,o.save(),!1!==i&&this.dispatch(o,r),o},b.prototype.dispatch=function(e,n){var i=0,o=0,r=this;function a(){var t=r.callbacks[i++];if(e.path===r.current)return t?void t(e,a):function(t){if(t.handled)return;var e,n=this._window;e=this._hashbang?y&&this._getBase()+n.location.hash.replace("#!",""):y&&n.location.pathname+n.location.search;if(e===t.canonicalPath)return;this.stop(),t.handled=!1,y&&(n.location.href=t.canonicalPath)}.call(r,e);e.handled=!1}n?function t(){var e=r.exits[o++];if(!e)return a();e(n,t)}():a()},b.prototype.exit=function(t,e){if("function"==typeof t)return this.exit("*",t);for(var n=new R(t,null,this),i=1;i<arguments.length;++i)this.exits.push(n.middleware(arguments[i]))},b.prototype.clickHandler=function(t){if(1===this._which(t)&&!(t.metaKey||t.ctrlKey||t.shiftKey||t.defaultPrevented)){var e=t.target,n=t.path||(t.composedPath?t.composedPath():null);if(n)for(var i=0;i<n.length;i++)if(n[i].nodeName&&"A"===n[i].nodeName.toUpperCase()&&n[i].href){e=n[i];break}for(;e&&"A"!==e.nodeName.toUpperCase();)e=e.parentNode;if(e&&"A"===e.nodeName.toUpperCase()){var o="object"==typeof e.href&&"SVGAnimatedString"===e.href.constructor.name;if(!e.hasAttribute("download")&&"external"!==e.getAttribute("rel")){var r=e.getAttribute("href");if((this._hashbang||!this._samePath(e)||!e.hash&&"#"!==r)&&!(r&&-1<r.indexOf("mailto:"))&&(o?!e.target.baseVal:!e.target)&&(o||this.sameOrigin(e.href))){var a=o?e.href.baseVal:e.pathname+e.search+(e.hash||"");a="/"!==a[0]?"/"+a:a,m&&a.match(/^\/[a-zA-Z]:\//)&&(a=a.replace(/^\/[a-zA-Z]:\//,"/"));var s=a,h=this._getBase();0===a.indexOf(h)&&(a=a.substr(h.length)),this._hashbang&&(a=a.replace("#!","")),(!h||s!==a||y&&"file:"===this._window.location.protocol)&&(t.preventDefault(),this.show(s))}}}}},b.prototype._onpopstate=(l=!1,g?(d&&"complete"===document.readyState?l=!0:window.addEventListener("load",function(){setTimeout(function(){l=!0},0)}),function(t){if(l)if(t.state){var e=t.state.path;this.replace(e,t.state)}else if(y){var n=this._window.location;this.show(n.pathname+n.search+n.hash,void 0,void 0,!1)}}):function(){}),b.prototype._which=function(t){return null==(t=t||g&&this._window.event).which?t.button:t.which},b.prototype._toURL=function(t){var e=this._window;if("function"==typeof URL&&y)return new URL(t,e.location.toString());if(d){var n=e.document.createElement("a");return n.href=t,n}},b.prototype.sameOrigin=function(t){if(!t||!y)return!1;var e=this._toURL(t),n=this._window.location;return n.protocol===e.protocol&&n.hostname===e.hostname&&n.port===e.port},b.prototype._samePath=function(t){if(!y)return!1;var e=this._window.location;return t.pathname===e.pathname&&t.search===e.search},b.prototype._decodeURLEncodedURIComponent=function(t){return"string"!=typeof t?t:this._decodeURLComponents?decodeURIComponent(t.replace(/\+/g," ")):t},E.prototype.pushState=function(){var t=this.page,e=t._window,n=t._hashbang;t.len++,v&&e.history.pushState(this.state,this.title,n&&"/"!==this.path?"#!"+this.path:this.canonicalPath)},E.prototype.save=function(){var t=this.page;v&&"file:"!==t._window.location.protocol&&t._window.history.replaceState(this.state,this.title,t._hashbang&&"/"!==this.path?"#!"+this.path:this.canonicalPath)},R.prototype.middleware=function(n){var i=this;return function(t,e){if(i.match(t.path,t.params))return n(t,e);e()}},R.prototype.match=function(t,e){var n=this.keys,i=t.indexOf("?"),o=~i?t.slice(0,i):t,r=this.regexp.exec(decodeURIComponent(o));if(!r)return!1;for(var a=1,s=r.length;a<s;++a){var h=n[a-1],c=this.page._decodeURLEncodedURIComponent(r[a]);void 0===c&&hasOwnProperty.call(e,h.name)||(e[h.name]=c)}return!0};var k=function t(){var e=new b;function n(){return x.apply(e,arguments)}return n.callbacks=e.callbacks,n.exits=e.exits,n.base=e.base.bind(e),n.strict=e.strict.bind(e),n.start=e.start.bind(e),n.stop=e.stop.bind(e),n.show=e.show.bind(e),n.back=e.back.bind(e),n.redirect=e.redirect.bind(e),n.replace=e.replace.bind(e),n.dispatch=e.dispatch.bind(e),n.exit=e.exit.bind(e),n.configure=e.configure.bind(e),n.sameOrigin=e.sameOrigin.bind(e),n.clickHandler=e.clickHandler.bind(e),n.create=t,Object.defineProperty(n,"len",{get:function(){return e.len},set:function(t){e.len=t}}),Object.defineProperty(n,"current",{get:function(){return e.current},set:function(t){e.current=t}}),n.Context=E,n.Route=R,n}(),U=k,L=k;return U.default=L,U});
/*!
 * EventEmitter v5.2.4 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */
!function(e){"use strict";function t(){}function n(e,t){for(var n=e.length;n--;)if(e[n].listener===t)return n;return-1}function r(e){return function(){return this[e].apply(this,arguments)}}function i(e){return"function"==typeof e||e instanceof RegExp||!(!e||"object"!=typeof e)&&i(e.listener)}var s=t.prototype,o=e.EventEmitter;s.getListeners=function(e){var t,n,r=this._getEvents();if(e instanceof RegExp){t={};for(n in r)r.hasOwnProperty(n)&&e.test(n)&&(t[n]=r[n])}else t=r[e]||(r[e]=[]);return t},s.flattenListeners=function(e){var t,n=[];for(t=0;t<e.length;t+=1)n.push(e[t].listener);return n},s.getListenersAsObject=function(e){var t,n=this.getListeners(e);return n instanceof Array&&(t={},t[e]=n),t||n},s.addListener=function(e,t){if(!i(t))throw new TypeError("listener must be a function");var r,s=this.getListenersAsObject(e),o="object"==typeof t;for(r in s)s.hasOwnProperty(r)&&n(s[r],t)===-1&&s[r].push(o?t:{listener:t,once:!1});return this},s.on=r("addListener"),s.addOnceListener=function(e,t){return this.addListener(e,{listener:t,once:!0})},s.once=r("addOnceListener"),s.defineEvent=function(e){return this.getListeners(e),this},s.defineEvents=function(e){for(var t=0;t<e.length;t+=1)this.defineEvent(e[t]);return this},s.removeListener=function(e,t){var r,i,s=this.getListenersAsObject(e);for(i in s)s.hasOwnProperty(i)&&(r=n(s[i],t),r!==-1&&s[i].splice(r,1));return this},s.off=r("removeListener"),s.addListeners=function(e,t){return this.manipulateListeners(!1,e,t)},s.removeListeners=function(e,t){return this.manipulateListeners(!0,e,t)},s.manipulateListeners=function(e,t,n){var r,i,s=e?this.removeListener:this.addListener,o=e?this.removeListeners:this.addListeners;if("object"!=typeof t||t instanceof RegExp)for(r=n.length;r--;)s.call(this,t,n[r]);else for(r in t)t.hasOwnProperty(r)&&(i=t[r])&&("function"==typeof i?s.call(this,r,i):o.call(this,r,i));return this},s.removeEvent=function(e){var t,n=typeof e,r=this._getEvents();if("string"===n)delete r[e];else if(e instanceof RegExp)for(t in r)r.hasOwnProperty(t)&&e.test(t)&&delete r[t];else delete this._events;return this},s.removeAllListeners=r("removeEvent"),s.emitEvent=function(e,t){var n,r,i,s,o,u=this.getListenersAsObject(e);for(s in u)if(u.hasOwnProperty(s))for(n=u[s].slice(0),i=0;i<n.length;i++)r=n[i],r.once===!0&&this.removeListener(e,r.listener),o=r.listener.apply(this,t||[]),o===this._getOnceReturnValue()&&this.removeListener(e,r.listener);return this},s.trigger=r("emitEvent"),s.emit=function(e){var t=Array.prototype.slice.call(arguments,1);return this.emitEvent(e,t)},s.setOnceReturnValue=function(e){return this._onceReturnValue=e,this},s._getOnceReturnValue=function(){return!this.hasOwnProperty("_onceReturnValue")||this._onceReturnValue},s._getEvents=function(){return this._events||(this._events={})},t.noConflict=function(){return e.EventEmitter=o,t},"function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:e.EventEmitter=t}(this||{});
/* docma (dust) compiled templates */
(function(dust){dust.register("docma-404",body_0);function body_0(chk,ctx){return chk.p("navbar",ctx,ctx,{"boxed":"true"}).w("<div id=\"page-content-wrapper\"><div class=\"container container-boxed\"><br /><br /><h1>404</h1><hr /><h3>Page Not Found</h3><br />The file or page you have requested is not found. &nbsp;&nbsp;<br />Please make sure page address is entered correctly.<br /><br /><br /></div></div>");}body_0.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("docma-api",body_0);function body_0(chk,ctx){return chk.p("navbar",ctx,ctx,{}).w("<div id=\"wrapper\">").x(ctx.getPath(false, ["template","options","sidebar","enabled"]),ctx,{"block":body_1},{}).w("<div id=\"page-content-wrapper\"><div class=\"container\"><br />").s(ctx.get(["documentation"], false),ctx,{"block":body_2},{}).w("<br /><span class=\"docma-info\">Documentation built with <b><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://onury.io/docma\">Docma</a></b>.</span></div></div></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div id=\"sidebar-wrapper\">").p("sidebar",ctx,ctx,{}).w("</div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.p("symbol",ctx,ctx,{"symbol":ctx.getPath(true, []),"template":ctx.get(["template"], false)});}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("docma-content",body_0);function body_0(chk,ctx){return chk.p("navbar",ctx,ctx,{"boxed":"true"}).w("<div id=\"page-content-wrapper\"><div class='").h("eq",ctx,{"block":body_1},{"key":ctx.getPath(false, ["currentRoute","sourceType"]),"value":"md"},"h").w("'><div id=\"docma-content\"></div>").h("eq",ctx,{"block":body_2},{"key":ctx.getPath(false, ["currentRoute","sourceType"]),"value":"md"},"h").w("</div></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("container container-boxed");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<br /><hr /><span class=\"docma-info\">Documentation built with <b><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://onury.io/docma\">Docma</a></b>.</span>");}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("enums",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["$members"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.h("eq",ctx,{"else":body_2,"block":body_4},{"key":ctx.getPath(false, ["template","options","symbols","enums"]),"value":"table"},"h");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"space-top-sm space-bottom-xs fw-bold\">Enumeration</div><ul class=\"param-list\">").s(ctx.get(["$members"], false),ctx,{"block":body_3},{}).w("</ul>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<li><div class=\"param-meta clearfix\"><span class=\"inline-block space-right-sm\"><code>").f(ctx.getPath(true, []),ctx,"h",["$longname","s","$dot_prop"]).w("</code>&nbsp;:&nbsp;<code>").f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></span><span class=\"param-info-box\"><span class=\"param-info value\">Value:&nbsp;</span><code>").f(ctx.getPath(true, []),ctx,"h",["$val"]).w("</code></span></div><div class=\"param-desc\">").f(ctx.getPath(true, []),ctx,"h",["s","$desc"]).w("</div></li>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<table class=\"table table-striped table-bordered\"><thead><tr><th>Enumeration</th><th>Type</th><th>Value</th><th>Description</th></tr></thead><tbody>").s(ctx.get(["$members"], false),ctx,{"block":body_5},{}).w("</tbody></table>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<tr><td><code>").f(ctx.getPath(true, []),ctx,"h",["$longname","s","$dot_prop"]).w("</code></td><td><code>").f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></td><td><code>").f(ctx.getPath(true, []),ctx,"h",["$val"]).w("</code></td><td>").f(ctx.getPath(true, []),ctx,"h",["s","$desc"]).w("</td></tr>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("navbar",body_0);function body_0(chk,ctx){return chk.x(ctx.getPath(false, ["template","options","navbar","enabled"]),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<nav class=\"navbar ").x(ctx.getPath(false, ["template","options","navbar","dark"]),ctx,{"block":body_2},{}).w("\"><div class=\"navbar-inner ").x(ctx.get(["boxed"], false),ctx,{"block":body_3},{}).w("\"><div class=\"navbar-brand\">").x(ctx.getPath(false, ["template","options","logo","dark"]),ctx,{"block":body_4},{}).w("<span class=\"navbar-title\"><a href=\"").f(ctx.getPath(false, ["template","options","title","href"]),ctx,"h").w("\">").f(ctx.getPath(false, ["template","options","title","label"]),ctx,"h").w("</a></span></div>").h("gt",ctx,{"block":body_7},{"key":ctx.getPath(false, ["template","options","navbar","menu","length"]),"value":0},"h").w("</div></nav>").x(ctx.getPath(false, ["template","options","navbar","fixed"]),ctx,{"block":body_16},{}).w("<div class=\"nav-overlay\"></div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("dark");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("container container-boxed");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.x(ctx.getPath(false, ["template","options","navbar","dark"]),ctx,{"else":body_5,"block":body_6},{});}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<img src=\"").f(ctx.getPath(false, ["template","options","logo","dark"]),ctx,"h").w("\" alt=\"logo\" class=\"navbar-logo\" />");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<img src=\"").f(ctx.getPath(false, ["template","options","logo","light"]),ctx,"h").w("\" alt=\"logo\" class=\"navbar-logo\" />");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<div class=\"navbar-menu-btn\" tabindex=\"0\"><i class=\"fas fa-lg fa-bars trans-all-ease\"></i><i class=\"fas fa-md fa-times trans-all-ease\"></i></div><div class=\"navbar-menu\"><ul class=\"navbar-list\">").s(ctx.getPath(false, ["template","options","navbar","menu"]),ctx,{"block":body_8},{}).w("</ul></div>");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.x(ctx.get(["items"], false),ctx,{"else":body_9,"block":body_10},{});}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.p("navitem",ctx,ctx.rebase(ctx.getPath(true, [])),{});}body_9.__dustBody=!0;function body_10(chk,ctx){return chk.w("<li class=\"dropdown\"><a href=\"").x(ctx.get(["href"], false),ctx,{"else":body_11,"block":body_12},{}).w("\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"><i class=\"nav-icon ").f(ctx.get(["iconClass"], false),ctx,"h").w("\" aria-hidden=\"true\"></i>").x(ctx.get(["label"], false),ctx,{"block":body_13},{}).x(ctx.get(["chevron"], false),ctx,{"block":body_14},{}).w("</a><ul>").s(ctx.get(["items"], false),ctx,{"block":body_15},{}).w("</ul></li>");}body_10.__dustBody=!0;function body_11(chk,ctx){return chk.w("#");}body_11.__dustBody=!0;function body_12(chk,ctx){return chk.f(ctx.get(["href"], false),ctx,"h");}body_12.__dustBody=!0;function body_13(chk,ctx){return chk.w("<span class=\"nav-label\">").f(ctx.get(["label"], false),ctx,"h").w("</span>");}body_13.__dustBody=!0;function body_14(chk,ctx){return chk.w("<i class=\"nav-arrow fas fa-sm fa-angle-down\"></i>");}body_14.__dustBody=!0;function body_15(chk,ctx){return chk.w(" ").p("navitem",ctx,ctx.rebase(ctx.getPath(true, [])),{}).w(" ");}body_15.__dustBody=!0;function body_16(chk,ctx){return chk.w("<div class=\"nav-spacer\"></div>");}body_16.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("navitem",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["separator"], false),ctx,{"else":body_1,"block":body_6},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<li><a href=\"").x(ctx.get(["href"], false),ctx,{"else":body_2,"block":body_3},{}).w("\" target=\"").f(ctx.get(["target"], false),ctx,"h").w("\">").x(ctx.get(["iconClass"], false),ctx,{"block":body_4},{}).x(ctx.get(["label"], false),ctx,{"block":body_5},{}).w("</a></li>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("#");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.f(ctx.get(["href"], false),ctx,"h");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<i class=\"nav-icon ").f(ctx.get(["iconClass"], false),ctx,"h").w("\" aria-hidden=\"true\"></i>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<span class=\"nav-label\">").f(ctx.get(["label"], false),ctx,"h",["s"]).w("</span>");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<li role=\"separator\" class=\"divider\"></li>");}body_6.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("params",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["params"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.h("eq",ctx,{"else":body_2,"block":body_8},{"key":ctx.getPath(false, ["template","options","symbols","params"]),"value":"table"},"h");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"space-top-sm space-bottom-xs fw-bold\">Parameters</div><ul class=\"param-list\">").s(ctx.get(["params"], false),ctx,{"block":body_3},{}).w("</ul>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<li><div class=\"param-meta clearfix\"><span class=\"inline-block space-right-sm\"><code>").x(ctx.get(["variable"], false),ctx,{"block":body_4},{}).f(ctx.get(["name"], false),ctx,"h",["s","$dot_prop"]).w("</code>&nbsp;:&nbsp;<code>").x(ctx.get(["variable"], false),ctx,{"block":body_5},{}).f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></span><span class=\"param-info-box\">").x(ctx.get(["optional"], false),ctx,{"else":body_6,"block":body_7},{}).w("</span></div><div class=\"param-desc\">").f(ctx.getPath(true, []),ctx,"h",["s","$param_desc"]).w("</div></li>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("...");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("...");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<span class=\"param-info required boxed\">Required</span>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<span class=\"param-info default\">Default:&nbsp;</span><code>").f(ctx.getPath(true, []),ctx,"h",["$def"]).w("</code>");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w("<table class=\"table table-striped table-bordered\"><thead><tr><th>Param</th><th>Type</th><th>Description</th></tr></thead><tbody>").s(ctx.get(["params"], false),ctx,{"block":body_9},{}).w("</tbody></table>");}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.w("<tr><td><code>").x(ctx.get(["variable"], false),ctx,{"block":body_10},{}).f(ctx.get(["name"], false),ctx,"h",["s","$dot_prop"]).w("</code></td><td><code>").x(ctx.get(["variable"], false),ctx,{"block":body_11},{}).f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></td><td>").x(ctx.get(["optional"], false),ctx,{"else":body_12,"block":body_13},{}).f(ctx.getPath(true, []),ctx,"h",["s","$param_desc"]).w("</td></tr>");}body_9.__dustBody=!0;function body_10(chk,ctx){return chk.w("...");}body_10.__dustBody=!0;function body_11(chk,ctx){return chk.w("...");}body_11.__dustBody=!0;function body_12(chk,ctx){return chk.w("<span class=\"param-info required boxed\">Required</span>");}body_12.__dustBody=!0;function body_13(chk,ctx){return chk.w("<span class=\"param-info default boxed\">Default</span><span class=\"color-gray\">:</span><code>").f(ctx.getPath(true, []),ctx,"h",["$def"]).w("</code>");}body_13.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("properties",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["properties"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.h("eq",ctx,{"else":body_2,"block":body_4},{"key":ctx.getPath(false, ["template","options","symbols","props"]),"value":"table"},"h");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"space-top-sm space-bottom-xs fw-bold\">Properties</div><ul class=\"param-list\">").s(ctx.get(["properties"], false),ctx,{"block":body_3},{}).w("</ul>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<li><div class=\"param-meta clearfix\"><span class=\"inline-block space-right-sm\"><code>").f(ctx.get(["name"], false),ctx,"h",["s","$dot_prop"]).w("</code>&nbsp;:&nbsp;<code>").f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></span></div><div class=\"param-desc\">").f(ctx.get(["description"], false),ctx,"h",["s","$p"]).w("</div></li>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<table class=\"table table-striped table-bordered\"><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>").s(ctx.get(["properties"], false),ctx,{"block":body_5},{}).w("</tbody></table>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<tr><td><code>").f(ctx.get(["name"], false),ctx,"h",["s","$dot_prop"]).w("</code></td><td><code>").f(ctx.getPath(true, []),ctx,"h",["s","$type"]).w("</code></td><td>").f(ctx.get(["description"], false),ctx,"h",["s","$p"]).w("</td></tr>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("sidebar",body_0);function body_0(chk,ctx){return chk.w("<div class=\"sidebar-header\"><div id=\"sidebar-toggle\"><i class=\"fas fa-lg fa-bars trans-all-ease\"></i></div><div class=\"sidebar-brand\">").x(ctx.getPath(false, ["template","options","logo","light"]),ctx,{"block":body_1},{}).w("<span class=\"sidebar-title\"><a href=\"").f(ctx.getPath(false, ["template","options","title","href"]),ctx,"h").w("\">").f(ctx.getPath(false, ["template","options","title","label"]),ctx,"h").w("</a></span></div>").x(ctx.getPath(false, ["template","options","sidebar","search"]),ctx,{"block":body_2},{}).x(ctx.getPath(false, ["template","options","sidebar","toolbar"]),ctx,{"block":body_3},{}).w("</div><div class=\"sidebar-nav-container\"><ul class=\"sidebar-nav\">").f(ctx.get(["symbols"], false),ctx,"h",["s","$navnodes"]).w("</ul></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<img src=\"").f(ctx.getPath(false, ["template","options","logo","light"]),ctx,"h").w("\" alt=\"logo\" class=\"sidebar-logo\" />");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"sidebar-search\"><div class=\"sidebar-search-icon\"><i class=\"fas fa-md fa-search\"></i></div><input id=\"txt-search\" type=\"search\" placeholder=\"Search...\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" /><div class=\"sidebar-search-clean\"><i class=\"fas fa-lg fa-times-circle\"></i></div></div>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<div class=\"sidebar-toolbar\"><div class=\"toolbar-scope-filters\"></div><div class=\"toolbar-kind-filters\"></div><div class=\"toolbar-buttons\"><span class=\"btn-switch-fold inline-block\" title=\"Fold Symbols\">").h("eq",ctx,{"else":body_4,"block":body_5},{"key":ctx.getPath(false, ["template","options","sidebar","itemsFolded"]),"type":"boolean","value":"true"},"h").w("</span><span class=\"btn-switch-outline inline-block space-left-xs\" title=\"Toggle Outline\">").h("eq",ctx,{"else":body_6,"block":body_7},{"key":ctx.getPath(false, ["template","options","sidebar","outline"]),"type":"string","value":"tree"},"h").w("</span></div></div>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<i class=\"far fa-lg fa-caret-square-down\"></i>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<i class=\"far fa-lg fa-caret-square-right\"></i>");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<i class=\"fas fa-lg fa-outdent\"></i>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<i class=\"fas fa-lg fa-indent\"></i>");}body_7.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("symbol",body_0);function body_0(chk,ctx){return chk.nx(ctx.getPath(false, ["symbol","$hide"]),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div id=\"").f(ctx.get(["symbol"], false),ctx,"h",["$id"]).w("\" class=\"symbol-container\"><div class=\"symbol-heading\"><div class=\"symbol\"><a href=\"#").f(ctx.get(["symbol"], false),ctx,"h",["$id"]).w("\"><i class=\"fas fa-link color-gray-light\" aria-hidden=\"true\"></i></a><code class=\"symbol-name\">").f(ctx.get(["symbol"], false),ctx,"h",["s","$longname_params"]).w("</code><span class=\"symbol-sep\">").f(ctx.get(["symbol"], false),ctx,"h",["$type_sep"]).w("</span><code class=\"symbol-type\">").f(ctx.get(["symbol"], false),ctx,"h",["s","$type"]).w("</code>").f(ctx.get(["symbol"], false),ctx,"h",["s","$tags"]).w("</div></div><div class=\"symbol-definition\"><div class=\"symbol-info\">").x(ctx.getPath(false, ["symbol","alias"]),ctx,{"block":body_2},{}).x(ctx.getPath(false, ["symbol","augments"]),ctx,{"block":body_4},{}).x(ctx.getPath(false, ["symbol","version"]),ctx,{"block":body_5},{}).x(ctx.getPath(false, ["symbol","since"]),ctx,{"block":body_6},{}).x(ctx.getPath(false, ["symbol","copyright"]),ctx,{"block":body_7},{}).x(ctx.getPath(false, ["symbol","author"]),ctx,{"block":body_8},{}).x(ctx.getPath(false, ["symbol","license"]),ctx,{"block":body_9},{}).w("</div>").x(ctx.getPath(false, ["symbol","defaultvalue"]),ctx,{"block":body_10},{}).f(ctx.get(["symbol"], false),ctx,"h",["s","$desc"]).x(ctx.getPath(false, ["symbol","see"]),ctx,{"block":body_11},{}).h("ne",ctx,{"block":body_16},{"key":ctx.getPath(false, ["symbol","meta","code","type"]),"value":"ClassDeclaration"},"h").x(ctx.getPath(false, ["symbol","fires"]),ctx,{"block":body_19},{}).x(ctx.getPath(false, ["symbol","returns"]),ctx,{"block":body_21},{}).x(ctx.getPath(false, ["symbol","generator"]),ctx,{"block":body_24},{}).x(ctx.getPath(false, ["symbol","exceptions"]),ctx,{"block":body_28},{}).x(ctx.getPath(false, ["symbol","isEnum"]),ctx,{"block":body_31},{}).x(ctx.getPath(false, ["symbol","examples"]),ctx,{"block":body_32},{}).x(ctx.getPath(false, ["template","options","symbols","meta"]),ctx,{"block":body_35},{}).w("</div></div><hr />").x(ctx.getPath(false, ["symbol","$constructor"]),ctx,{"block":body_39},{}).nx(ctx.getPath(false, ["symbol","isEnum"]),ctx,{"block":body_41},{});}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.nx(ctx.get(["$constructor"], false),ctx,{"block":body_3},{});}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<p><b class=\"caption\">Alias:</b> <code>").f(ctx.getPath(false, ["symbol","alias"]),ctx,"h",["s","$dot_prop"]).w("</code></p>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<p><b class=\"caption\">Extends:</b> ").f(ctx.get(["symbol"], false),ctx,"h",["s","$extends"]).w("</p>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<p><b class=\"caption\">Version:</b>&nbsp;").f(ctx.getPath(false, ["symbol","version"]),ctx,"h",["s"]).w("</p>");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<p><b class=\"caption\">Since:</b>&nbsp;").f(ctx.getPath(false, ["symbol","since"]),ctx,"h",["s"]).w("</p>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<p><b class=\"caption\">Copyright:</b>&nbsp;").f(ctx.getPath(false, ["symbol","copyright"]),ctx,"h",["s"]).w("</p>");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w("<p><b class=\"caption\">Author:</b>&nbsp;").f(ctx.getPath(false, ["symbol","author"]),ctx,"h",["s","$author"]).w("</p>");}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.w("<p><b class=\"caption\">License:</b>&nbsp;").f(ctx.getPath(false, ["symbol","license"]),ctx,"h",["s"]).w("</p>");}body_9.__dustBody=!0;function body_10(chk,ctx){return chk.w("<p class=\"symbol-def-val\"><b class=\"caption\"><i>Value:</i></b>&nbsp;<code>").f(ctx.get(["symbol"], false),ctx,"h",["$def"]).w("</code></p>");}body_10.__dustBody=!0;function body_11(chk,ctx){return chk.w("<p class=\"no-margin\"><b>See</b>").h("gt",ctx,{"else":body_12,"block":body_14},{"key":ctx.getPath(false, ["symbol","see","length"]),"value":1},"h").w("</p>");}body_11.__dustBody=!0;function body_12(chk,ctx){return chk.s(ctx.getPath(false, ["symbol","see"]),ctx,{"block":body_13},{});}body_12.__dustBody=!0;function body_13(chk,ctx){return chk.w("&nbsp;").f(ctx.getPath(true, []),ctx,"h",["s","$pl"]);}body_13.__dustBody=!0;function body_14(chk,ctx){return chk.w("<ul>").s(ctx.getPath(false, ["symbol","see"]),ctx,{"block":body_15},{}).w("</ul>");}body_14.__dustBody=!0;function body_15(chk,ctx){return chk.w("<li>").f(ctx.getPath(true, []),ctx,"h",["s","$pl"]).w("</li>");}body_15.__dustBody=!0;function body_16(chk,ctx){return chk.p("params",ctx,ctx.rebase(ctx.get(["symbol"], false)),{"template":ctx.get(["template"], false)}).w(" ").x(ctx.getPath(false, ["symbol","isEnum"]),ctx,{"else":body_17,"block":body_18},{});}body_16.__dustBody=!0;function body_17(chk,ctx){return chk.p("properties",ctx,ctx.rebase(ctx.get(["symbol"], false)),{"template":ctx.get(["template"], false)}).w(" ");}body_17.__dustBody=!0;function body_18(chk,ctx){return chk;}body_18.__dustBody=!0;function body_19(chk,ctx){return chk.h("gt",ctx,{"block":body_20},{"key":ctx.getPath(false, ["symbol","fires","length"]),"value":"0","type":"number"},"h");}body_19.__dustBody=!0;function body_20(chk,ctx){return chk.w("<p><b class=\"caption\">Emits:</b>&nbsp;&nbsp;").f(ctx.get(["symbol"], false),ctx,"h",["s","$emits"]).w("</p>");}body_20.__dustBody=!0;function body_21(chk,ctx){return chk.h("gt",ctx,{"else":body_22,"block":body_23},{"key":ctx.getPath(false, ["symbol","returns","length"]),"value":"1","type":"number"},"h");}body_21.__dustBody=!0;function body_22(chk,ctx){return chk.w("<p><b class=\"caption\">Returns:</b>&nbsp;&nbsp;").f(ctx.get(["symbol"], false),ctx,"h",["s","$returns"]).w("</p>");}body_22.__dustBody=!0;function body_23(chk,ctx){return chk.w("<b class=\"caption\">Returns:</b><p class=\"pad-left\">").f(ctx.get(["symbol"], false),ctx,"h",["s","$returns"]).w("</p>");}body_23.__dustBody=!0;function body_24(chk,ctx){return chk.x(ctx.getPath(false, ["symbol","yields"]),ctx,{"block":body_25},{});}body_24.__dustBody=!0;function body_25(chk,ctx){return chk.h("gt",ctx,{"else":body_26,"block":body_27},{"key":ctx.getPath(false, ["symbol","yields","length"]),"value":"1","type":"number"},"h");}body_25.__dustBody=!0;function body_26(chk,ctx){return chk.w("<p><b class=\"caption\">Yields:</b>&nbsp;&nbsp;").f(ctx.get(["symbol"], false),ctx,"h",["s","$yields"]).w("</p>");}body_26.__dustBody=!0;function body_27(chk,ctx){return chk.w("<b class=\"caption\">Yields:</b><p class=\"pad-left\">").f(ctx.get(["symbol"], false),ctx,"h",["s","$yields"]).w("</p>");}body_27.__dustBody=!0;function body_28(chk,ctx){return chk.h("gt",ctx,{"else":body_29,"block":body_30},{"key":ctx.getPath(false, ["symbol","exceptions","length"]),"value":"1","type":"number"},"h");}body_28.__dustBody=!0;function body_29(chk,ctx){return chk.w("<p><b class=\"caption\">Throws:</b>&nbsp;&nbsp;").f(ctx.get(["symbol"], false),ctx,"h",["s","$exceptions"]).w("</p>");}body_29.__dustBody=!0;function body_30(chk,ctx){return chk.w("<b class=\"caption\">Throws:</b><p class=\"pad-left\">").f(ctx.get(["symbol"], false),ctx,"h",["s","$exceptions"]).w("</p>");}body_30.__dustBody=!0;function body_31(chk,ctx){return chk.p("enums",ctx,ctx.rebase(ctx.get(["symbol"], false)),{"template":ctx.get(["template"], false)}).w(" ");}body_31.__dustBody=!0;function body_32(chk,ctx){return chk.s(ctx.getPath(false, ["symbol","examples"]),ctx,{"block":body_33},{});}body_32.__dustBody=!0;function body_33(chk,ctx){return chk.w("<p><b>Example").h("gt",ctx,{"block":body_34},{"key":ctx.getPath(false, ["symbol","examples","length"]),"value":1},"h").w("</b>").f(ctx.getPath(true, []),ctx,"h",["$get_caption","s"]).w("</p><pre><code>").f(ctx.getPath(true, []),ctx,"h",["$nt","$tnl","$remove_caption"]).w("</code></pre>");}body_33.__dustBody=!0;function body_34(chk,ctx){return chk.w("&nbsp;#").h("math",ctx,{},{"key":ctx.get(["$idx"], false),"method":"add","operand":"1"},"h");}body_34.__dustBody=!0;function body_35(chk,ctx){return chk.x(ctx.getPath(false, ["symbol","meta","lineno"]),ctx,{"block":body_36},{});}body_35.__dustBody=!0;function body_36(chk,ctx){return chk.w("<p class=\"symbol-meta\">").x(ctx.getPath(false, ["symbol","meta","filename"]),ctx,{"block":body_37},{}).x(ctx.getPath(false, ["symbol","meta","lineno"]),ctx,{"block":body_38},{}).w("</p>");}body_36.__dustBody=!0;function body_37(chk,ctx){return chk.w("<b>File:</b> ").f(ctx.getPath(false, ["symbol","meta","filename"]),ctx,"h").w("&nbsp;&nbsp;");}body_37.__dustBody=!0;function body_38(chk,ctx){return chk.w("<b>Line:</b> ").f(ctx.getPath(false, ["symbol","meta","lineno"]),ctx,"h").w("&nbsp;&nbsp;");}body_38.__dustBody=!0;function body_39(chk,ctx){return chk.h("ne",ctx,{"block":body_40},{"key":ctx.getPath(false, ["symbol","hideconstructor"]),"type":"boolean","value":"true"},"h");}body_39.__dustBody=!0;function body_40(chk,ctx){return chk.p("symbol",ctx,ctx,{"symbol":ctx.getPath(false, ["symbol","$constructor"]),"template":ctx.get(["template"], false)});}body_40.__dustBody=!0;function body_41(chk,ctx){return chk.s(ctx.getPath(false, ["symbol","$members"]),ctx,{"block":body_42},{});}body_41.__dustBody=!0;function body_42(chk,ctx){return chk.p("symbol",ctx,ctx,{"symbol":ctx.getPath(true, []),"template":ctx.get(["template"], false)});}body_42.__dustBody=!0;return body_0}(dust));
/*!
 * Docma (Web) Core
 * https://github.com/onury/docma
 * @license MIT
 */
var DocmaWeb = (function () {
'use strict';

var Utils={};function getStr(e){return"string"==typeof e?e.trim():""}function bracket(e){return/^[a-z$_][a-z\d$_]*$/i.test(e)?"."+e:'["'+e+'"]'}function fixBracket(r){return r.replace(/(.*?)\."([^"]+)"\]?$/,function(e,t,n){return n?t+bracket(n):r})}function cleanName(e){return fixBracket(e=getStr(e).replace(/([^>]+>)?~?(.*)/,"$2").replace(/^"[^"]+"\.?~?([^"]+)$/,"$1").replace(/^(module\.)?exports\./,"").replace(/^module:/,""))}function getMetaCodeName(e){return cleanName(Utils.notate(e,"meta.code.name")||"")}function identity(e){return e}function hasConstructorTag(e){return/\*\s+@construct(s|or)\b/.test(e.comment)}Utils.type=function(e){return Object.prototype.toString.call(e).match(/\s(\w+)/i)[1].toLowerCase()},Utils.notate=function(e,t){if("object"==typeof e){var n,r=Array.isArray(t)?t:t.split("."),i=r[0];if(i)return n=e[i],1<r.length?(r.shift(),Utils.notate(n,r)):n}},Utils.getName=function(e){if(e.alias){var t=getMetaCodeName(e);if(t)return t.replace(/.*?[#.~:](\w+)$/i,"$1")}return e.name},Utils.getLongName=function(e){var t=cleanName(e.longname),n=getMetaCodeName(e)||t,r=e.memberof||"";if(r=/^".*"$/.test(r)?"":cleanName(r),e.name===r&&Utils.isConstructor(e))return n;var i=e.alias?n:t;if(!r)return i;var l=new RegExp("^"+r+"[#.~:]"),o="instance"===e.scope?"#":".";return l.test(i)?i:r+o+i},Utils.getFullName=Utils.getLongName,Utils.getCodeName=function(e){return getMetaCodeName(e)||Utils.getLongName(e)},Utils.getSymbolByName=function(e,t){var n,r,i,l;if("object"===Utils.type(e)){var o=Object.keys(e);for(n=0;n<o.length;n++)if(i=e[o[n]].documentation,l=Utils.getSymbolByName(i,t))return l;return null}for(i=e,n=0;n<i.length;n++){if((r=i[n]).name===t||r.longname===t||Utils.getFullName(r)===t)return r;if(r.$members&&(l=Utils.getSymbolByName(r.$members,t)))return l}return null},Utils.getLevels=function(e){var t=("string"==typeof e?e:e.$longname)||"";return(t=cleanName(t))?((t||"").split(/[.#~]/)||[]).length:0},Utils.getParentName=function(e){var t;if("string"!=typeof e){if(e.memberof&&!1===/^".*"$/.test(e.memberof))return cleanName(e.memberof);t=cleanName(e.$longname)}else t=cleanName(e);return t&&/[.#~]/g.test(t)?t.replace(/[.#~][^.#~]*$/,""):""},Utils.getParent=function(e,t){var n="string"==typeof t?Utils.getSymbolByName(e,t):t;if(!n)return null;var r=Utils.getParentName(n);return r?Utils.getSymbolByName(e,r):null},Utils.isDeprecated=function(e){return e.deprecated},Utils.isGlobal=function(e){return"global"===e.scope},Utils.isNamespace=function(e){return"namespace"===e.kind},Utils.isModule=function(e){return"module"===e.kind},Utils.isMixin=function(e){return"mixin"===e.kind},Utils.isClass=function(e){return"class"===e.kind&&"MethodDefinition"!==Utils.notate(e,"meta.code.type")&&!hasConstructorTag(e)},Utils.isConstant=function(e){return"constant"===e.kind},Utils.isConstructor=function(e){return"class"===e.kind&&("MethodDefinition"===Utils.notate(e,"meta.code.type")||hasConstructorTag(e))},Utils.isStaticMember=function(e){return"static"===e.scope},Utils.isStatic=Utils.isStaticMember,Utils.isInner=function(e){return"inner"===e.scope},Utils.isInstanceMember=function(e){return"instance"===e.scope},Utils.isInterface=function(e){return"interface"===e.scope},Utils.isMethod=function(e){var t=Utils.notate(e,"meta.code.type");return"function"===e.kind||"FunctionExpression"===t||"FunctionDeclaration"===t},Utils.isFunction=Utils.isMethod,Utils.isInstanceMethod=function(e){return Utils.isInstanceMember(e)&&Utils.isMethod(e)},Utils.isStaticMethod=function(e){return Utils.isStaticMember(e)&&Utils.isMethod(e)},Utils.isProperty=function(e){return"member"===e.kind&&!Utils.isMethod(e)},Utils.isInstanceProperty=function(e){return Utils.isInstanceMember(e)&&Utils.isProperty(e)},Utils.isStaticProperty=function(e){return Utils.isStaticMember(e)&&Utils.isProperty(e)},Utils.isTypeDef=function(e){return"typedef"===e.kind},Utils.isCustomType=Utils.isTypeDef,Utils.isCallback=function(e){var t=(e.type||{}).names||[];return"typedef"===e.kind&&0<=(e.comment||"").indexOf("@callback "+e.longname)&&1===t.length&&"function"===t[0]},Utils.isEnum=function(e){return Boolean(e.isEnum)},Utils.isEvent=function(e){return"event"===e.kind},Utils.isExternal=function(e){return"external"===e.kind},Utils.isGenerator=function(e){return e.generator&&"function"===e.kind},Utils.isReadOnly=function(e){return e.readonly},Utils.isPublic=function(e){return"string"!=typeof e.access||"public"===e.access},Utils.isPrivate=function(e){return"private"===e.access},Utils.isPackagePrivate=function(e){return"package"===e.access},Utils.isProtected=function(e){return"protected"===e.access},Utils.isUndocumented=function(e){return!e.comments},Utils.hasDescription=function(e){return Boolean(getStr(e.classdesc)||getStr(e.description))},Utils.trimLeft=function(e){return e.replace(/^[\s\n\r\-—]*/,"")},Utils.trimNewLines=function(e){return e.replace(/^[\r\n]+|[\r\n]+$/,"")},Utils.parseTicks=function(e){return"string"!=typeof e?"":e.replace(/(```\s*)([\s\S]*?)(\s*```)/g,function(e,t,n){return Utils.normalizeTabs(Utils._wrapCode(n,!0,!0).replace(/`/g,"&#x60;"))}).replace(/(`)(.*?)(`)/g,function(e,t,n){return Utils._wrapCode(n,!0)})},Utils.parseNewLines=function(e,r){return r=r||{},Utils._tokenize(e,function(e,t){if(t)return e;var n=e.split(/[\r\n]{2,}/);return n.length<=1&&r.keepIfSingle?e:n.map(function(e){return"<p>"+e+"</p>"}).join("")}).join("")},Utils.parseLinks=function(e,l){if("string"!=typeof e)return"";l=l||{};var t=e.replace(/\{@link +([^}]*?)\}/g,function(e,t){var n,r,i=t.split("|");return 1===i.length?n=r=i[0].trim():(n=i[0].trim(),r=i[1].trim()),!1===/[/?&=]/.test(n)&&"#"!==n[0]&&(n="#"+n),'<a href="'+n+'"'+(l.target?' target="'+l.target+'" rel="noopener noreferrer"':"")+">"+r+"</a>"});return Utils.parseTicks(t)},Utils.parse=function(e,t){return t=t||{},e=Utils.trimLeft(e),e=Utils.parseNewLines(e,t),e=Utils.parseTicks(e),Utils.parseLinks(e,t)},Utils.normalizeTabs=function(e){if("string"!=typeof e)return"";var r,t=e.match(/^\s*/gm),n=1/0;if(t.forEach(function(e,t){e=e.replace(/\t/g,"  "),0<t&&(n=Math.min(e.length,n))}),n!==1/0){var i=new RegExp("^\\s{"+n+"}","g");e=e.replace(i,"")}return(e=e.replace(/^\s*/,"")).replace(/([\r\n]+)(\s+)/gm,function(e,t,n){return r=n.replace(/\t/g,"  "),t+(r=new Array(r.length-r.length%2+1).join(" "))})},Utils.getKeywords=function(e){if("string"==typeof e)return e.toLowerCase();var t=Utils.getFullName(e)+" "+e.longname+" "+e.name+" "+(e.alias||"")+" "+(e.memberOf||"")+" "+(e.$kind||"")+" "+(e.scope||"")+" "+(e.classdesc||"")+" "+(e.description||"")+" "+(e.filename||"")+" "+(e.readonly?"readonly":"")+(e.isEnum?"enum":"");return Utils.isConstructor(e)&&(t+=" constructor"),Utils.isMethod(e)&&(t+=" method"),Utils.isProperty(e)&&(t+=" property"),t.replace(/[><"'`\n\r]/g,"").toLowerCase()},Utils.getCodeFileInfo=function(e){return{filename:Utils.notate(e,"meta.filename"),lineno:Utils.notate(e,"meta.lineno"),path:Utils.notate(e,"meta.path")}},Utils.getSymbolLink=function(e,t){if("string"!=typeof t)return t.$docmaLink;var n=Utils.getSymbolByName(e,t);return n?n.$docmaLink:""};var reEndBrackets=/\[\]$/,reTypeParts=/^([^<]+?)(?:\.)?(?:<\(([^>)]+)\)>)?(?:<([^>]+)>)?(\[\])?$/;function _link(e,t,n){var r,i=reEndBrackets.test(t)?"[]":"",l=(t||"").replace(reEndBrackets,""),o=n||{},a="";return"internal"!==o.linkType&&(r=Utils._getTypeExternalLink(l))&&(a=' target="_blank" rel="noopener noreferrer"'),r||"external"===o.linkType||(r=Utils.getSymbolLink(e,l)),r&&(t='<a href="'+r+'"'+a+">"+(o.displayText||l)+i+"</a>"),t}function serializer(r){var i=[],l=[];return function(e,t){if(2e3<i.length)return"[Too Big Object]";if(0<i.length){var n=i.indexOf(this);~n?(i.splice(n+1),l.splice(n,1/0,e)):(i.push(this),l.push(e)),0<=i.indexOf(t)&&(t=i[0]===t?"[Circular ~]":"[Circular ~."+l.slice(0,i.indexOf(t)).join(".")+"]")}else i.push(t);return r?r.call(this,e,t):t}}function decodeHash(e){return decodeURIComponent(e).replace(/^#/,"")}Utils._parseAnchorLinks=function(t,e,n){var r=e.match(reTypeParts);if(!r||!r[1])return"";var i=r[4]||"",l=r[2]||r[3]||"";return l=(l=l&&l.split(",").map(function(e){return e.trim().split("|").map(function(e){return _link(t,e,n)}).join('<span class="code-delim">|</span>')}).join('<span class="code-delim">, </span>'))&&"&lt;"+l+"&gt;",_link(t,r[1],n)+l+i},Utils.getTypes=function(t,e,n){var r=n||{},i="class"===e.kind?["class"]:Utils.notate(e,"type.names")||[];return i=i.map(function(e){return r.links&&(e=Utils._parseAnchorLinks(t,e,{linkType:r.links})),e}).join('<span class="code-delim">|</span>'),e.isEnum?"enum&lt;"+i+"&gt;":i},Utils.getReturnTypes=function(r,e,t){var n=e.returns;if(!Array.isArray(n))return"void";var i=t||{},l=n.reduce(function(e,t){var n=Utils.notate(t,"type.names")||[];return i.links&&(n=n.map(function(e){return Utils._parseAnchorLinks(r,e,{linkType:i.links})})),e.concat(n)},[]);return 0<l.length?l.join('<span class="code-delim">|</span>'):"void"},Utils.getCodeTags=function(n,e,t){var r=t||{};return e.map(function(e){if(r.links){var t=Utils._parseAnchorLinks(n,e,{linkType:r.links});return Utils._wrapCode(t,!1)}return Utils._wrapCode(e,!0)}).join(r.demileter||",")},Utils.getFormattedTypeList=function(n,e,t){if(!Array.isArray(e)||0===e.length)return"";var r=t||{},i='<span class="code-delim">'+(r.delimeter||"|")+"</span>",l="boolean"!=typeof r.descriptions||r.descriptions,o=r.descDelimeter||"&nbsp;&nbsp;—&nbsp;&nbsp;",a="",s=e.map(function(e){return l&&(a=(a=Utils.parse(e.description||"",{keepIfSingle:!0}))&&o+a),e.type?(e.type.names||[]).map(function(e){if(r.links){var t=Utils._parseAnchorLinks(n,e,{linkType:r.links});return Utils._wrapCode(t,!1)}return Utils._wrapCode(e,!0)}).join(i)+a:a?"— "+a:""});return 1<s.length?"<ul><li>"+s.join("</li><li>")+"</li></ul>":s},Utils.getEmittedEvents=function(n,e,t){if(!e||0===e.length)return"";var r,i,l=t||{},o=l.delimeter||", ";return(e||[]).map(function(e){if(r=e.split(/\s*[\s-—]\s*/g),i=(r[0]||"").trim(),l.links){var t=Utils._parseAnchorLinks(n,i,{linkType:l.links});return Utils._wrapCode(t,!1)}return Utils._wrapCode(i,!0)}).join(o)},Utils._find=function(e,t){if(!e||!t)return null;var n,r,i=null;for(n=0;n<e.length;n++)if((r=e[n])&&"object"==typeof r){for(var l in t)if(void 0!==t[l]&&t.hasOwnProperty(l)){if(t[l]!==r[l]){i=null;break}i=r}if(i)break}return i},Utils._assign=function(e,t,n){var r;for(r in e=e||{},t)t.hasOwnProperty(r)&&(n?Object.defineProperty(e,r,{enumerable:!0,value:t[r]}):e[r]=t[r]);return e},Utils._values=function(e){if(Array.isArray(e))return e;var t,n=[];for(t in e)e.hasOwnProperty(t)&&n.push(e[t]);return n},Utils._wrapCode=function(e,t,n){return"string"!=typeof e?"":(void 0!==t&&!0!==t||(e=e.replace(/</g,"&lt;").replace(/>/g,"&gt;")),e="<code>"+e+"</code>",n?"<pre>"+e+"</pre>":e)},Utils._tokenize=function(e,t){"function"!=typeof t&&(t=identity);if(e.indexOf("```")<0)return[t(e,!1)];var n,r="```".length,i="",l="",o=[],a=!1;for(n=0;n<e.length;n++)i+=e[n],l+=e[n],i.length>r&&(i=i.slice(-r)),"```"===i&&(l=(a=!a)?(o.push(t(l.slice(0,-r),!1)),i):(o.push(t(l,!0)),""));return o},Utils._ensureSlash=function(e,t,n){return t?(e&&"/"!==t.slice(0,1)&&(t="/"+t),n&&"/"!==t.slice(-1)&&(t+="/"),t):e||n?"/":""},Utils._safeStringify=function(t,e,n){try{return JSON.stringify(t,serializer(e),n)}catch(e){return String(t)}},Utils.DOM={};var ATTR_BODY_STYLE="data-body-style";Utils.DOM.getOffset=function(e){var t="object"==typeof e?e:document.getElementById(e);if(t){var n=t.getBoundingClientRect();if(n.width||n.height||t.getClientRects().length){var r=document.documentElement;return{top:n.top+window.pageYOffset-r.clientTop,left:n.left+window.pageXOffset-r.clientLeft}}}},Utils.DOM.scrollTo=function(e){var t=document.documentElement||document.body;if(e=decodeHash(e||window.location.hash||"")){var n=document.getElementById(e);if(n){var r=Utils.DOM.getOffset(n);r&&(t.scrollTop=r.top)}}else t.scrollTop=0},Utils.DOM._createChild=function(e,t,n){n=n||{};var r=document.createElement(t||"div");return Object.keys(n).forEach(function(e){r[e]=n[e]}),e.appendChild(r),r},Utils.DOM._removePrevBodyStyles=function(){for(var e=document.getElementsByTagName("head")[0].querySelectorAll("["+ATTR_BODY_STYLE+"]");0<e.length;)e[0].parentNode.removeChild(e[0])},Utils.DOM._moveBodyStylesToHead=function(){var e,t,n=document.getElementsByTagName("head")[0],r=document.body.getElementsByTagName("style");for(e=0;e<r.length;e++)(t=r[e]).parentNode.removeChild(t),t.setAttribute(ATTR_BODY_STYLE,""),n.appendChild(t)};var _builtinURLs={globals:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/",statements:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/",operators:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/",functions:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/",web:"https://developer.mozilla.org/en-US/docs/Web/API/"},_builtins={globals:["Infinity","NaN","undefined","null","Object","Function","function","Boolean","boolean","Symbol","Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","Number","number","Math","Date","String","string","RegExp","Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Map","Set","WeakMap","WeakSet","ArrayBuffer","DataView","JSON","Promise","Generator","GeneratorFunction","Reflect","Proxy","TypedArray","Intl","Intl.Collator","Intl.DateTimeFormat","Intl.NumberFormat","WebAssembly","WebAssembly.Module","WebAssembly.Instance","WebAssembly.Memory","WebAssembly.Table","WebAssembly.CompileError","WebAssembly.LinkError","WebAssembly.RuntimeError"],statements:["function","function*","async function","class","debugger"],operators:["void","super","this"],functions:["arguments"],web:["AbstractWorker","AnalyserNode","AudioBuffer","AudioContext","AudioListener","AudioNode","BaseAudioContext","BeforeUnloadEvent","Blob","BlobEvent","BufferSource","ByteString","CSSMediaRule","CSSPageRule","CSSPrimitiveValue","CSSRule","CSSRuleList","CSSStyleDeclaration","CSSStyleRule","CSSStyleSheet","CSSSupportsRule","CSSValue","CSSValueList","CloseEvent","CompositionEvent","Console","Coordinates","Crypto","CryptoKey","CustomEvent","DOMException","DOMImplementation","Document","DocumentFragment","DocumentType","DoubleRange","DragEvent","Element","ErrorEvent","Event","EventListener","EventSource","EventTarget","File","FileList","FileReader","FileReaderSync","FormData","Geolocation","HTMLAnchorElement","HTMLAreaElement","HTMLAudioElement","HTMLBRElement","HTMLBaseElement","HTMLBodyElement","HTMLButtonElement","HTMLCanvasElement","HTMLCollection","HTMLDListElement","HTMLDataElement","HTMLDataListElement","HTMLDetailsElement","HTMLDivElement","HTMLDocument","HTMLElement","HTMLEmbedElement","HTMLFieldSetElement","HTMLFormControlsCollection","HTMLFormElement","HTMLHRElement","HTMLHeadElement","HTMLHeadingElement","HTMLHtmlElement","HTMLIFrameElement","HTMLImageElement","HTMLInputElement","HTMLKeygenElement","HTMLLIElement","HTMLLabelElement","HTMLLegendElement","HTMLLinkElement","HTMLMapElement","HTMLMediaElement","HTMLMetaElement","HTMLMeterElement","HTMLModElement","HTMLOListElement","HTMLObjectElement","HTMLOptGroupElement","HTMLOptionElement","HTMLOptionsCollection","HTMLOutputElement","HTMLParagraphElement","HTMLParamElement","HTMLPreElement","HTMLProgressElement","HTMLQuoteElement","HTMLScriptElement","HTMLSelectElement","HTMLSlotElement","HTMLSourceElement","HTMLSpanElement","HTMLStyleElement","HTMLTableCaptionElement","HTMLTableCellElement","HTMLTableColElement","HTMLTableDataCellElement","HTMLTableElement","HTMLTableHeaderCellElement","HTMLTableRowElement","HTMLTableSectionElement","HTMLTemplateElement","HTMLTextAreaElement","HTMLTimeElement","HTMLTitleElement","HTMLTrackElement","HTMLUListElement","HTMLUnknownElement","HTMLVideoElement","HashChangeEvent","History","ImageData","InputEvent","KeyboardEvent","LinkStyle","Location","LongRange","MediaDevices","MediaDeviceInfo","MediaError","MediaRecorder","MediaStream","MessageChannel","MessageEvent","MessagePort","MouseEvent","MutationObserver","MutationRecord","NamedNodeMap","Navigator","NavigatorGeolocation","Node","NodeIterator","NodeList","NonDocumentTypeChildNode","Notification","PageTransitionEvent","PointerEvent","PopStateEvent","Position","PositionError","PositionOptions","ProgressEvent","PromiseRejectionEvent","RTCCertificate","RTCConfiguration","RTCDTMFSender","RTCDTMFToneChangeEvent","RTCDataChannel","RTCPeerConnection","RTCPeerConnection","RTCRtpCodecParameters","RTCRtpContributingSource","RTCRtpReceiver","RTCRtpSender","RTCRtpSynchronizationSource","RTCRtpTransceiver","RTCRtpTransceiverDirection","RTCRtpTransceiverInit","RTCStatsReport","RadioNodeList","RandomSource","Range","RenderingContext","SVGAnimateElement","SVGAnimateMotionElement","SVGAnimateTransformElement","SVGAnimationElement","SVGCircleElement","SVGClipPathElement","SVGCursorElement","SVGElement","SVGEllipseElement","SVGEvent","SVGFilterElement","SVGGeometryElement","SVGGradientElement","SVGGraphicsElement","SVGImageElement","SVGLineElement","SVGLinearGradientElement","SVGMPathElement","SVGMaskElement","SVGMetadataElement","SVGPathElement","SVGPatternElement","SVGPolygonElement","SVGPolylineElement","SVGRadialGradientElement","SVGRect","SVGRectElement","SVGSVGElement","SVGScriptElement","SVGSetElement","SVGStopElement","SVGStyleElement","SVGSwitchElement","SVGSymbolElement","SVGTSpanElement","SVGTextContentElement","SVGTextElement","SVGTextPathElement","SVGTextPositioningElement","SVGTitleElement","SVGTransform","SVGTransformList","SVGTransformable","SVGUseElement","SVGViewElement","ShadowRoot","SharedWorker","Storage","StorageEvent","StyleSheet","StyleSheetList","Text","TextMetrics","TimeEvent","TimeRanges","Touch","TouchEvent","TouchList","Transferable","TreeWalker","UIEvent","URL","WebGLActiveInfo","WebGLBuffer","WebGLContextEvent","WebGLFramebuffer","WebGLProgram","WebGLRenderbuffer","WebGLRenderingContext","WebGLShader","WebGLTexture","WebGLUniformLocation","WebGLVertexArrayObject","WebSocket","WheelEvent","Window","Worker","WorkerGlobalScope","WorkerLocation","WorkerNavigator","XMLHttpRequest","XMLHttpRequestEventTarget","XMLSerializer","XPathExpression","XPathResult","XSLTProcessor"]},_cats=Object.keys(_builtins);Utils._getTypeExternalLink=function(e){var t,n;for(t=0;t<_cats.length;t++)if(n=_cats[t],0<=_builtins[n].indexOf(e))return _builtinURLs[n]+(e||"").replace(/^([^.]*\.)/,"");return""};

function DocmaWeb(t){this._=t||{},this._.initialLoad=!1,this._.appEntranceRI=null,this._.emitter=new EventEmitter,Object.defineProperty(this,"app",{configurable:!1,get:function(){return this._.app||null}}),Object.defineProperty(this,"apis",{configurable:!1,get:function(){return this._.apis||{}}}),Object.defineProperty(this,"routes",{configurable:!1,get:function(){return this._.routes||{}}}),Object.defineProperty(this,"template",{configurable:!1,get:function(){return this._.template||{}}}),Object.defineProperty(this,"location",{configurable:!1,get:function(){var t=Utils._ensureSlash(!0,window.location.pathname,!0),e=Utils._ensureSlash(!0,docma.app.base,!0),o=t;return t.slice(0,e.length)===e&&(o=t.slice(e.length-1,t.length)),{host:window.location.host,hostname:window.location.hostname,origin:window.location.origin,port:window.location.port,protocol:(window.location.protocol||"").replace(/:$/,""),entrance:Utils._ensureSlash(!0,docma.app.entrance,!1),base:e,hash:(window.location.hash||"").replace(/^#/,""),query:(window.location.search||"").replace(/^\?/,""),href:window.location.href,fullpath:t,pathname:o,path:o+(window.location.search||""),getQuery:function(t,e){"?"===(e=void 0===e?window.location.search||"":e).slice(0,1)&&(e=e.slice(1)),t=(t||"").replace(/[[\]]/g,"\\$&");var o=new RegExp("&?"+t+"(=([^&#]*)|&|#|$)").exec(e);return o&&o[2]?decodeURIComponent(o[2].replace(/\+/g," ")):""}}}}),Object.defineProperty(this,"currentRoute",{configurable:!1,get:function(){return this._.currentRoute||null}}),Object.defineProperty(this,"documentation",{configurable:!1,get:function(){return this._.documentation||[]}}),Object.defineProperty(this,"symbols",{configurable:!1,get:function(){return this._.symbols||[]}})}DocmaWeb.prototype._trigger=function(t,e){this.info("Event:",t,e?e[0]:""),this._.emitter.trigger(t,e)},DocmaWeb.Event={Ready:"ready",Render:"render",Route:"route",Navigate:"navigate"},DocmaWeb.prototype.on=function(t,e){return this._.emitter.on.apply(this._.emitter,arguments),docma},DocmaWeb.prototype.once=function(){return this._.emitter.once.apply(this._.emitter,arguments),this},DocmaWeb.prototype.off=function(){return this._.emitter.off.apply(this._.emitter,arguments),this},DocmaWeb.prototype.addListener=DocmaWeb.prototype.on,DocmaWeb.prototype.addListenerOnce=DocmaWeb.prototype.once,DocmaWeb.prototype.removeListener=DocmaWeb.prototype.off,DocmaWeb.prototype.log=function(){docma._.logsEnabled&&console.log.apply(console,arguments)},DocmaWeb.prototype.info=function(){docma._.logsEnabled&&console.info.apply(console,arguments)},DocmaWeb.prototype.warn=function(){docma._.logsEnabled&&console.warn.apply(console,arguments)},DocmaWeb.prototype.error=function(){docma._.logsEnabled&&console.error.apply(console,arguments)},DocmaWeb.prototype.getDocmaElem=function(){var t=document.getElementById(this._.elementID);return t=t||Utils.DOM.createChild(document.body,"div",{id:this._.elementID})},DocmaWeb.prototype.getContentElem=function(){var t=document.getElementById(this._.contentElementID);if(!t)throw new Error("Partial "+this._.partials.content+' should have an element with id="'+this._.contentElementID+'".');return t},DocmaWeb.prototype.loadContent=function(t){this.getContentElem().innerHTML=t,Utils.DOM._removePrevBodyStyles(),Utils.DOM._moveBodyStylesToHead(),Utils.DOM.scrollTo()},DocmaWeb.prototype._loadCompiledContent=function(t){this.getDocmaElem().innerHTML=t},DocmaWeb.prototype._fixAnchors=function(r){this.app.base&&setTimeout(function(){var t,e,o=document.querySelectorAll('a[href^="#"]');for(t=0;t<o.length;t++){var n=(e=o[t]).getAttribute("href");"#"===n.slice(0,1)&&1<n.length&&(n=window.location.pathname+(window.location.search||"")+n,e.setAttribute("href",n))}"function"==typeof r&&r()},50)},DocmaWeb.prototype.addFilter=function(t,e){if(this.filterExists(t))throw new Error('Filter "'+t+'" already exists.');return dust.filters[t]=e,this},DocmaWeb.prototype.removeFilter=function(t){return delete dust.filters[t],this},DocmaWeb.prototype.filterExists=function(t){return"function"==typeof dust.filters[t]},DocmaWeb.prototype.createRoute=function(t,e){return new DocmaWeb.Route(this,t,e)},DocmaWeb.prototype.createRouteFromID=function(t){if("string"!=typeof t)return this.warn("Route ID is not a string: "+t),new DocmaWeb.Route(this,null);var e=t.split(":");return new DocmaWeb.Route(this,e[1],e[0])},DocmaWeb.prototype.createRouteFromQuery=function(t){if(!t)return new DocmaWeb.Route(null);var e=t.split("&")[0].split("="),o=e[0].toLowerCase(),n=e[1];return new DocmaWeb.Route(this,n,o)},DocmaWeb.prototype._render=function(o,n){var r=this;dust.render(o,this,function(t,e){if(t)throw r.warn("Could not load Docma partial:",o),r.log("Compiled HTML: ",e),t;r._loadCompiledContent(e),"function"==typeof n&&n()})},DocmaWeb.prototype._triggerAfterRender=function(){this._trigger(DocmaWeb.Event.Render,[docma.currentRoute]),this._.initialLoad&&(this._trigger(DocmaWeb.Event.Ready),this._.initialLoad=!1)},DocmaWeb.prototype._render404=function(t,e){this._.currentRoute=this.createRoute(null);var o=this;this._render(this._.partials.notFound,function(){if(o._trigger(DocmaWeb.Event.Render,[null]),Utils.DOM.scrollTo(),"function"==typeof e)return e(404);throw new Error("Page or content not found for route: "+Utils._safeStringify(t))})},DocmaWeb.prototype.fetch=function(e,o){var n=new XMLHttpRequest,r=this;n.onreadystatechange=function(){if(4===n.readyState){var t=200===n.status?n.responseText:"";return r.log("XHR GET:",n.status,e),o(n.status,t)}},n.open("GET",e,!0),n.send()},DocmaWeb.prototype.render=function(o,n){if(!o||!o.exists())return this._render404(o,n);if(!o.isEqualTo(this.currentRoute)){this._.currentRoute=o;var r="function"==typeof n,i=this;o.type===DocmaWeb.Route.Type.API?this._render(this._.partials.api,function(){i._triggerAfterRender(),r&&n(200),i._fixAnchors(function(){Utils.DOM.scrollTo()})}):docma.fetch(o.contentPath,function(t,e){if(404===t)return i._render404(o,n);i._render(i._.partials.content,function(){i.loadContent(e),i._triggerAfterRender(),r&&n(t),i._fixAnchors(function(){Utils.DOM.scrollTo()})})})}},DocmaWeb.Utils=Utils;

var _arrRouteTypes;DocmaWeb.Route=function(t,e,o){if(this._docma=t,o&&!(_arrRouteTypes.indexOf(o)<0)){if(e)t.app.routing.caseSensitive||(e=e.toLowerCase());else{if(o!==DocmaWeb.Route.Type.API)return;e=t._.defaultApiName}var i=Utils._find(t.routes,{type:o,name:e});i&&Utils._assign(this,i)}},DocmaWeb.Route.Type={API:"api",CONTENT:"content"},_arrRouteTypes=Utils._values(DocmaWeb.Route.Type),DocmaWeb.Route.SourceType={JS:"js",MD:"md",HTML:"html"},DocmaWeb.Route.prototype.exists=function(){return Boolean(this.id)},DocmaWeb.Route.prototype.isEqualTo=function(t){return!!(t&&t.exists()&&this.exists())&&t.path===this.path},DocmaWeb.Route.prototype.isCurrent=function(){return this.isEqualTo(this._docma.currentRoute)},DocmaWeb.Route.prototype.apply=function(t){return this.type===DocmaWeb.Route.Type.API?(this._docma._.documentation=this._docma.apis[this.name].documentation,this._docma._.symbols=this._docma.apis[this.name].symbols):(this._docma._.documentation=null,this._docma._.symbols=null),this._docma._trigger(DocmaWeb.Event.Route,[this.exists()?this:null]),this._docma.render(this,t),this},DocmaWeb.Route.prototype.toString=function(){var e=this.toJSON();return Object.keys(e).map(function(t){return t+": "+e[t]}).join(", ")},DocmaWeb.Route.prototype.toJSON=function(){return{id:this.id,contentPath:this.contentPath,path:this.path,type:this.type,sourceType:this.sourceType,name:this.name}};

dust.filters=dust.filters||{},dust.filters.$pt=function(e){return DocmaWeb.Utils.parseTicks(e)},dust.filters.$pnl=function(e){return DocmaWeb.Utils.parseNewLines(e,{keepIfSingle:!0})},dust.filters.$pl=function(e){return DocmaWeb.Utils.parseLinks(e)},dust.filters.$tl=function(e){return DocmaWeb.Utils.trimLeft(e)},dust.filters.$tnl=function(e){return DocmaWeb.Utils.trimNewLines(e)},dust.filters.$p=function(e){return DocmaWeb.Utils.parse(e,{keepIfSingle:!0})},dust.filters.$nt=function(e){return DocmaWeb.Utils.normalizeTabs(e)},dust.filters.$desc=function(e){return DocmaWeb.Utils.parse(e.classdesc||e.description||"")};var reJSValues=/true|false|null|undefined|Infinity|NaN|\d+|Number\.\w+|Math\.(PI|E|LN(2|10)|LOG(2|10)E|SQRT(1_)?2)|\[.*?]|\{.*?}|new [a-zA-Z]+.*|\/.+\/[gmiu]*|Date\.(now\(\)|UTC\(.*)|window|document/;function getFormatValue(e,t){if(arguments.length<2&&(t=DocmaWeb.Utils.notate(e,"meta.code.value")||e.defaultvalue),"string"!=typeof t)return String(t);var n=DocmaWeb.Utils.notate(e,"type.names")||[];return!/['"`]/.test(t.slice(0,1))&&0<=n.indexOf("String")&&(1===n.length||-1===reJSValues.indexOf(t))?'"'+t+'"':String(t)}dust.filters.$def=function(e){return e.hasOwnProperty("defaultvalue")?getFormatValue(e,e.defaultvalue):"undefined"},dust.filters.$val=function(e){return getFormatValue(e)},dust.filters.$id=function(e){var t;"string"==typeof e?t=e:t=(DocmaWeb.Utils.isConstructor(e)?"new-":"")+e.$longname;return t.replace(/ /g,"-")};

DocmaWeb.version = "3.2.2";
return DocmaWeb;
})();
var docma = Object.freeze(new DocmaWeb({"version":"3.2.2","routes":[{"id":"api:","type":"api","name":"_def_","path":"api/","contentPath":null,"sourceType":"js"},{"id":"content:changelog","type":"content","name":"changelog","path":"changelog/","contentPath":"content/changelog.html","sourceType":"md"},{"id":"content:guide","type":"content","name":"guide","path":"guide/","contentPath":"content/guide.html","sourceType":"md"}],"apis":{"_def_":{"documentation":[{"comment":"/**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */","meta":{"range":[3345,3706],"filename":"notation.js","lineno":79,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002573","name":"Notation","type":"MethodDefinition","paramnames":["source","options"]},"vars":{"":null}},"description":"Initializes a new instance of `Notation`.","params":[{"type":{"names":["Object","Array"]},"optional":true,"defaultvalue":"{}","description":"The source object (or array) to be\n notated. Can either be an array or object. If omitted, defaults to an\n empty object.","name":"source"},{"type":{"names":["Object"]},"optional":true,"description":"Notation options.","name":"options"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether to throw either when\n     a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     methods); or notation path exists but overwriting is disabled (i.e.\n     `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     are exceptions). It's recommended to set this to `true` and prevent silent\n     failures if you're working with sensitive data. Regardless of `strict` option,\n     it will always throw on invalid notation syntax or other crucial failures.","name":"options.strict"}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n const notation = new Notation(obj);\n notation.get('car.model')   // » \"Charger\"\n notation.remove('car.model').set('car.color', 'red').value\n // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }"],"name":"Notation","longname":"Notation","kind":"class","scope":"global","undocumented":true,"$longname":"Notation","$kind":"constructor","$docmaLink":"api/#Notation"},{"comment":"/**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\n     *  notated. Can either be an array or object. If omitted, defaults to an\n     *  empty object.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     *      methods); or notation path exists but overwriting is disabled (i.e.\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\n     *      it will always throw on invalid notation syntax or other crucial failures.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = new Notation(obj);\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */","meta":{"range":[3345,3706],"filename":"notation.js","lineno":79,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002573","name":"Notation","type":"MethodDefinition","paramnames":["source","options"]}},"name":"Notation","longname":"Notation","kind":"class","description":"Initializes a new instance of `Notation`.","examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n const notation = new Notation(obj);\n notation.get('car.model')   // » \"Charger\"\n notation.remove('car.model').set('car.color', 'red').value\n // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }"],"scope":"global","classdesc":"Notation.js for Node and Browser.\n\n Like in most programming languages, JavaScript makes use of dot-notation to\n access the value of a member of an object (or class). `Notation` class\n provides various methods for modifying / processing the contents of the\n given object; by parsing object notation strings or globs.\n\n Note that this class will only deal with enumerable properties of the source\n object; so it should be used to manipulate data objects. It will not deal\n with preserving the prototype-chain of the given object.","author":["Onur Yıldırım <onur@cutepilot.com>"],"license":"MIT","params":[{"type":{"names":["Object","Array"]},"optional":true,"defaultvalue":"{}","description":"The source object (or array) to be\n notated. Can either be an array or object. If omitted, defaults to an\n empty object.","name":"source"},{"type":{"names":["Object"]},"optional":true,"description":"Notation options.","name":"options"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether to throw either when\n     a notation path does not exist on the source (i.e. `#get()` and `#remove()`\n     methods); or notation path exists but overwriting is disabled (i.e.\n     `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\n     are exceptions). It's recommended to set this to `true` and prevent silent\n     failures if you're working with sensitive data. Regardless of `strict` option,\n     it will always throw on invalid notation syntax or other crucial failures.","name":"options.strict"}],"$longname":"Notation","$kind":"constructor","$docmaLink":"api/#Notation"},{"comment":"/**\n     *  Deeply clones the source object. This is also useful if you want to\n     *  prevent mutating the original source object.\n     *\n     *  <blockquote>\n     *  Note that `Notation` expects a data object (or array) with enumerable\n     *  properties. In addition to plain objects and arrays; supported cloneable\n     *  property/value types are primitives (such as `String`, `Number`,\n     *  `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\n     *  `Date` and `RegExp`).\n     *\n     *  Enumerable properties with types other than these (such as methods,\n     *  special objects, custom class instances, etc) will be copied by reference.\n     *  Non-enumerable properties will not be cloned.\n     *\n     *  If you still need full clone support, you can use a library like lodash.\n     *  e.g. `Notation.create(_.cloneDeep(source))`\n     *  </blockquote>\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const mutated = Notation.create(source1).set('newProp', true).value;\n     *  console.log(source1.newProp); // ——» true\n     *\n     *  const cloned = Notation.create(source2).clone().set('newProp', true).value;\n     *  console.log('newProp' in source2); // ——» false\n     *  console.log(cloned.newProp); // ——» true\n     */","meta":{"range":[8711,8801],"filename":"notation.js","lineno":234,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002762","name":"Notation#clone","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Deeply clones the source object. This is also useful if you want to\n prevent mutating the original source object.\n\n <blockquote>\n Note that `Notation` expects a data object (or array) with enumerable\n properties. In addition to plain objects and arrays; supported cloneable\n property/value types are primitives (such as `String`, `Number`,\n `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\n `Date` and `RegExp`).\n\n Enumerable properties with types other than these (such as methods,\n special objects, custom class instances, etc) will be copied by reference.\n Non-enumerable properties will not be cloned.\n\n If you still need full clone support, you can use a library like lodash.\n e.g. `Notation.create(_.cloneDeep(source))`\n </blockquote>","returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const mutated = Notation.create(source1).set('newProp', true).value;\n console.log(source1.newProp); // ——» true\n\n const cloned = Notation.create(source2).clone().set('newProp', true).value;\n console.log('newProp' in source2); // ——» false\n console.log(cloned.newProp); // ——» true"],"name":"clone","longname":"Notation#clone","kind":"function","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#clone","$kind":"method","$docmaLink":"api/#Notation#clone"},{"comment":"/**\n     *  Copies the notated property from the target collection and adds it to\n     *  (own) source object — only if the target object actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the copied\n     *  property on our source collection. In other words, the copied property\n     *  will be renamed to this value before set. If not set, `notation`\n     *  argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  our collection if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */","meta":{"range":[41940,42337],"filename":"notation.js","lineno":977,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004217","name":"Notation#copyFrom","type":"MethodDefinition","paramnames":["target","notation","newNotation","overwrite"]},"vars":{"":null}},"description":"Copies the notated property from the target collection and adds it to\n (own) source object — only if the target object actually has that\n property. This is different than a property with a value of `undefined`.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object","Array"]},"description":"The target collection that the notated\n properties will be copied from.","name":"target"},{"type":{"names":["String"]},"description":"The notation to get the corresponding\n property from the target object.","name":"notation"},{"type":{"names":["String"]},"optional":true,"defaultvalue":null,"description":"The notation to set the copied\n property on our source collection. In other words, the copied property\n will be renamed to this value before set. If not set, `notation`\n argument will be used.","name":"newNotation"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite the property on\n our collection if it exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `target` is not a valid collection."},{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const models = { dodge: \"Charger\" };\n Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\n console.log(obj);\n // { car: { brand: \"Ford\", model: \"Charger\" } }\n // models object is not modified"],"name":"copyFrom","longname":"Notation#copyFrom","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#copyFrom","$kind":"method","$docmaLink":"api/#Notation#copyFrom"},{"comment":"/**\n     *  Copies the notated property from the source collection and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination object that the notated\n     *  properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source property\n     *  on the destination object. In other words, the copied property will be\n     *  renamed to this value before set on the destination object. If not set,\n     *  `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // source object (obj) is not modified\n     */","meta":{"range":[40073,40483],"filename":"notation.js","lineno":937,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004154","name":"Notation#copyTo","type":"MethodDefinition","paramnames":["destination","notation","newNotation","overwrite"]},"vars":{"":null}},"description":"Copies the notated property from the source collection and adds it to the\n destination — only if the source object actually has that property.\n This is different than a property with a value of `undefined`.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object","Array"]},"description":"The destination object that the notated\n properties will be copied to.","name":"destination"},{"type":{"names":["String"]},"description":"The notation to get the corresponding property\n from the source object.","name":"notation"},{"type":{"names":["String"]},"optional":true,"defaultvalue":null,"description":"The notation to set the source property\n on the destination object. In other words, the copied property will be\n renamed to this value before set on the destination object. If not set,\n `notation` argument will be used.","name":"newNotation"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite the property on\n the destination object if it exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `destination` is not a valid collection."},{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const models = { dodge: \"Charger\" };\n Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\n console.log(models);\n // { dodge: \"Charger\", ford: \"Mustang\" }\n // source object (obj) is not modified"],"name":"copyTo","longname":"Notation#copyTo","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#copyTo","$kind":"method","$docmaLink":"api/#Notation#copyTo"},{"comment":"/**\n     *  Counts the number of notes/levels in the given notation.\n     *  @alias Notation.countLevels\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {Number} - Number of notes.\n     *  @throws {NotationError} - If given notation is invalid.\n     */","meta":{"range":[53768,53851],"filename":"notation.js","lineno":1272,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004584","name":"Notation.countNotes","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Counts the number of notes/levels in the given notation.","alias":"Notation.countLevels","params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"}],"returns":[{"type":{"names":["Number"]},"description":"- Number of notes."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"name":"countLevels","longname":"Notation.countLevels","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.countNotes","$kind":"method","$docmaLink":"api/#Notation.countNotes"},{"comment":"/**\n     *  Basically constructs a new `Notation` instance.\n     *  @chainable\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\n     *  @param {Object} [options] - Notation options.\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\n     *      notation path does not exist on the source. (Note that `.inspectGet()`\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\n     *      set this to `true` and prevent silent failures if you're working\n     *      with sensitive data. Regardless of `strict` option, it will always\n     *      throw on invalid notation syntax or other crucial failures.\n     *\n     *  @returns {Notation} - The created instance.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\n     *  notation.get('car.model')   // » \"Charger\"\n     *  notation.remove('car.model').set('car.color', 'red').value\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\n     */","meta":{"range":[51533,51702],"filename":"notation.js","lineno":1213,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004505","name":"Notation.create","type":"MethodDefinition","paramnames":["source","options"]},"vars":{"":null}},"description":"Basically constructs a new `Notation` instance.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object","Array"]},"optional":true,"defaultvalue":"{}","description":"The source collection to be notated.","name":"source"},{"type":{"names":["Object"]},"optional":true,"description":"Notation options.","name":"options"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether to throw when a\n     notation path does not exist on the source. (Note that `.inspectGet()`\n     and `.inspectRemove()` methods are exceptions). It's recommended to\n     set this to `true` and prevent silent failures if you're working\n     with sensitive data. Regardless of `strict` option, it will always\n     throw on invalid notation syntax or other crucial failures.","name":"options.strict"}],"returns":[{"type":{"names":["Notation"]},"description":"- The created instance."}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n const notation = Notation.create(obj); // equivalent to new Notation(obj)\n notation.get('car.model')   // » \"Charger\"\n notation.remove('car.model').set('car.color', 'red').value\n // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }"],"name":"create","longname":"Notation.create","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.create","$kind":"method","$docmaLink":"api/#Notation.create"},{"comment":"/**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each on each non-object value. To break out of the loop, return `false`\n     *  from within the callback.\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj).each(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */","meta":{"range":[5596,5678],"filename":"notation.js","lineno":154,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002672","name":"Notation#each","type":"MethodDefinition","paramnames":["callback"]},"vars":{"":null}},"description":"Recursively iterates through each key of the source object and invokes\n the given callback function with parameters, on each non-object value.","params":[{"type":{"names":["function"]},"description":"The callback function to be invoked on\n each on each non-object value. To break out of the loop, return `false`\n from within the callback.\n Callback signature: `callback(notation, key, value, object) { ... }`","name":"callback"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n Notation.create(obj).each(function (notation, key, value, object) {\n     console.log(notation, value);\n });\n // \"car.brand\"  \"Dodge\"\n // \"car.model\"  \"Charger\"\n // \"car.year\"  1970"],"name":"each","longname":"Notation#each","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#each","$kind":"method","$docmaLink":"api/#Notation#each"},{"comment":"/**\n     *  Iterates through each note/level of the given notation string.\n     *  @alias Notation.eachLevel\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within the\n     *  callback.\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @returns {void}\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  const notation = 'first.prop2.last';\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0  \"first\"             \"first\"\n     *  // 1  \"first.prop2\"       \"prop2\"\n     *  // 2  \"first.prop2.last\"  \"last\"\n     */","meta":{"range":[56438,56759],"filename":"notation.js","lineno":1351,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004672","name":"Notation.eachNote","type":"MethodDefinition","paramnames":["notation","callback"]},"vars":{"":null}},"description":"Iterates through each note/level of the given notation string.","alias":"Notation.eachLevel","params":[{"type":{"names":["String"]},"description":"The notation string to be iterated through.","name":"notation"},{"type":{"names":["function"]},"description":"The callback function to be invoked on\n each iteration. To break out of the loop, return `false` from within the\n callback.\n Callback signature: `callback(levelNotation, note, index, list) { ... }`","name":"callback"}],"returns":[{"type":{"names":["void"]}}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"examples":["const notation = 'first.prop2.last';\n Notation.eachNote(notation, function (levelNotation, note, index, list) {\n     console.log(index, note, levelNotation);\n });\n // 0  \"first\"             \"first\"\n // 1  \"first.prop2\"       \"prop2\"\n // 2  \"first.prop2.last\"  \"last\""],"name":"eachLevel","longname":"Notation.eachLevel","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.eachNote","$kind":"method","$docmaLink":"api/#Notation.eachNote"},{"comment":"/**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *  each iteration. To break out of the loop, return `false` from within\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */","meta":{"range":[6499,6844],"filename":"notation.js","lineno":177,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002686","name":"Notation#eachValue","type":"MethodDefinition","paramnames":["notation","callback"]},"vars":{"":null}},"description":"Iterates through each note of the given notation string by evaluating\n it on the source object.","params":[{"type":{"names":["String"]},"description":"The notation string to be iterated through.","name":"notation"},{"type":{"names":["function"]},"description":"The callback function to be invoked on\n each iteration. To break out of the loop, return `false` from within\n the callback. Signature: `callback(levelValue, note, index, list)`","name":"callback"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n Notation.create(obj)\n     .eachValue(\"car.brand\", function (levelValue, note, index, list) {\n         console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     });"],"name":"eachValue","longname":"Notation#eachValue","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#eachValue","$kind":"method","$docmaLink":"api/#Notation#eachValue"},{"comment":"/**\n *  Error class specific to `Notation`.\n *  @class\n *  @name Notation.Error\n */","meta":{"filename":"notation.error.js","lineno":5,"columnno":0,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Error class specific to `Notation`.","kind":"class","name":"Error","memberof":"Notation","longname":"Notation.Error","scope":"static","$longname":"Notation.Error","$kind":"class","$docmaLink":"api/#Notation.Error"},{"comment":"/**\n     *  Aggregates notated keys of a (single-level) object, and nests them under\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\n     *  method. This might be useful when expanding a flat object fetched from\n     *  a database.\n     *  @alias Notation#aggregate\n     *  @chainable\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     *  const expanded = Notation.create(obj).expand().value;\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     */","meta":{"range":[10133,10240],"filename":"notation.js","lineno":277,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002812","name":"Notation#expand","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Aggregates notated keys of a (single-level) object, and nests them under\n their corresponding properties. This is the opposite of `Notation#flatten`\n method. This might be useful when expanding a flat object fetched from\n a database.","alias":"Notation#aggregate","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n const expanded = Notation.create(obj).expand().value;\n console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };"],"name":"aggregate","longname":"Notation#aggregate","kind":"function","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#expand","$kind":"method","$docmaLink":"api/#Notation#expand"},{"comment":"/**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source collection. This is equivalent to `.copyTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // obj is not modified\n     */","meta":{"range":[48593,48718],"filename":"notation.js","lineno":1132,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004439","name":"Notation#extract","type":"MethodDefinition","paramnames":["notation","newNotation"]},"vars":{"":null}},"description":"Extracts the property at the given notation to a new object by copying\n it from the source collection. This is equivalent to `.copyTo({},\n notation, newNotation)`.","alias":"Notation#copyToNew","params":[{"type":{"names":["String"]},"description":"The notation to get the corresponding\n property (value) from the source object.","name":"notation"},{"type":{"names":["String"]},"description":"The new notation to be set on the new\n object for the targeted property value. If not set, `notation` argument\n will be used.","name":"newNotation"}],"returns":[{"type":{"names":["Object"]},"description":"- Returns a new object with the notated property."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\n console.log(extracted);\n // { carBrand: \"Ford\" }\n // obj is not modified"],"name":"copyToNew","longname":"Notation#copyToNew","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#extract","$kind":"method","$docmaLink":"api/#Notation#extract"},{"comment":"/**\n     *  Extrudes the property at the given notation to a new collection by\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\n     *  notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new\n     *  object for the targeted property value. If not set, `notation` argument\n     *  will be used.\n     *\n     *  @returns {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(obj);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */","meta":{"range":[49914,50039],"filename":"notation.js","lineno":1171,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004472","name":"Notation#extrude","type":"MethodDefinition","paramnames":["notation","newNotation"]},"vars":{"":null}},"description":"Extrudes the property at the given notation to a new collection by\n moving it from the source collection. This is equivalent to `.moveTo({},\n notation, newNotation)`.","alias":"Notation#moveToNew","params":[{"type":{"names":["String"]},"description":"The notation to get the corresponding\n property (value) from the source object.","name":"notation"},{"type":{"names":["String"]},"description":"The new notation to be set on the new\n object for the targeted property value. If not set, `notation` argument\n will be used.","name":"newNotation"}],"returns":[{"type":{"names":["Object"]},"description":"- Returns a new object with the notated property."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\n console.log(obj);\n // { car: { model: \"Mustang\" } }\n console.log(extruded);\n // { carBrand: \"Ford\" }"],"name":"moveToNew","longname":"Notation#moveToNew","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#extrude","$kind":"method","$docmaLink":"api/#Notation#extrude"},{"comment":"/**\n     *  Deep clones the source object while filtering its properties by the\n     *  given <b>glob</b> notations. Includes all matched properties and removes\n     *  the rest.\n     *\n     *  The difference between regular notations and glob-notations is that;\n     *  with the latter, you can use wildcard stars (*) and negate the notation\n     *  by prepending a bang (!). A negated notation will be excluded.\n     *\n     *  Order of the globs does not matter; they will be logically sorted. Loose\n     *  globs will be processed first and verbose globs or normal notations will\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\n     *\n     *  Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\n     *  the source object. See `Notation.Glob` class for more information.\n     *  @chainable\n     *\n     *  @param {Array|String} globList - Glob notation list to be processed.\n     *  @param {Object} [options] - Filter options.\n     *  @param {Boolean} [options.restrictive=false] - Whether negated items\n     *  strictly remove every match. Note that, regardless of this option, if\n     *  any item has an exact negated version; non-negated is always removed.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self). To get the\n     *  filtered value, call `.value` property on the instance.\n     *\n     *  @example\n     *  const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\n     *  const n = Notation.create(car);\n     *\n     *  console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\n     *  console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\n     *  console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\n     *  console.log(n.filter().value);                        // {} // —» equivalent to n.filter(\"\") or n.filter(\"!*\")\n     */","meta":{"range":[28788,37430],"filename":"notation.js","lineno":701,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003598","name":"Notation#filter","type":"MethodDefinition","paramnames":["globList","options"]},"vars":{"":null}},"description":"Deep clones the source object while filtering its properties by the\n given <b>glob</b> notations. Includes all matched properties and removes\n the rest.\n\n The difference between regular notations and glob-notations is that;\n with the latter, you can use wildcard stars (*) and negate the notation\n by prepending a bang (!). A negated notation will be excluded.\n\n Order of the globs does not matter; they will be logically sorted. Loose\n globs will be processed first and verbose globs or normal notations will\n be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\n normalized and sorted as `[ \"*\", \"!car\" ]`.\n\n Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\n the source object. See `Notation.Glob` class for more information.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Array","String"]},"description":"Glob notation list to be processed.","name":"globList"},{"type":{"names":["Object"]},"optional":true,"description":"Filter options.","name":"options"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether negated items\n strictly remove every match. Note that, regardless of this option, if\n any item has an exact negated version; non-negated is always removed.","name":"options.restrictive"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self). To get the\n filtered value, call `.value` property on the instance."}],"examples":["const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\n const n = Notation.create(car);\n\n console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\n console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\n console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\n console.log(n.filter().value);                        // {} // —» equivalent to n.filter(\"\") or n.filter(\"!*\")"],"name":"filter","longname":"Notation#filter","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#filter","$kind":"method","$docmaLink":"api/#Notation#filter"},{"comment":"/**\n     *  Gets the first (root) note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - First note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */","meta":{"range":[54411,54485],"filename":"notation.js","lineno":1295,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004608","name":"Notation.first","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Gets the first (root) note of the notation string.","params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"}],"returns":[{"type":{"names":["String"]},"description":"- First note."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"examples":["Notation.first('first.prop2.last'); // \"first\""],"name":"first","longname":"Notation.first","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.first","$kind":"method","$docmaLink":"api/#Notation.first"},{"comment":"/**\n     *  Flattens the source object to a single-level object with notated keys.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  console.log(Notation.create(obj).flatten().value);\n     *  // {\n     *  //     \"car.brand\": \"Dodge\",\n     *  //     \"car.model\": \"Charger\",\n     *  //     \"car.year\": 1970\n     *  // }\n     */","meta":{"range":[9275,9452],"filename":"notation.js","lineno":253,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002780","name":"Notation#flatten","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Flattens the source object to a single-level object with notated keys.","returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n console.log(Notation.create(obj).flatten().value);\n // {\n //     \"car.brand\": \"Dodge\",\n //     \"car.model\": \"Charger\",\n //     \"car.year\": 1970\n // }"],"name":"flatten","longname":"Notation#flatten","kind":"function","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#flatten","$kind":"method","$docmaLink":"api/#Notation#flatten"},{"comment":"/**\n     *  Gets the value of the corresponding property at the given notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} [defaultValue] - The default value to be returned if the\n     *  property is not found or enumerable.\n     *\n     *  @returns {*} - The value of the notated property.\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\n     *  is not set and notation does not exist.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     *\n     *  @example <caption>get value when strict option is enabled</caption>\n     *  // strict option defaults to false\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n     *  // below will throw bec. strict = true, car.model does not exist\n     *  // and no default value is given.\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\n     */","meta":{"range":[19373,19833],"filename":"notation.js","lineno":495,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003179","name":"Notation#get","type":"MethodDefinition","paramnames":["notation","defaultValue"]},"vars":{"":null}},"description":"Gets the value of the corresponding property at the given notation.","params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"},{"type":{"names":["String"]},"optional":true,"description":"The default value to be returned if the\n property is not found or enumerable.","name":"defaultValue"}],"returns":[{"type":{"names":["*"]},"description":"- The value of the notated property."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `strict` option is enabled, `defaultValue`\n is not set and notation does not exist."}],"examples":["Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n\n ","<caption>get value when strict option is enabled</caption>\n // strict option defaults to false\n Notation.create({ car: {} }).get(\"car.model\"); // undefined\n Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\n // below will throw bec. strict = true, car.model does not exist\n // and no default value is given.\n Notation.create({ car: {} }, { strict: true }).get(\"car.model\");"],"name":"get","longname":"Notation#get","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#get","$kind":"method","$docmaLink":"api/#Notation#get"},{"comment":"/**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @returns {Array} - An array of notation strings.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  const notations = Notation.create(obj).getNotations();\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */","meta":{"range":[7238,7383],"filename":"notation.js","lineno":197,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002738","name":"Notation#getNotations","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Gets the list of notations from the source object (keys).","returns":[{"type":{"names":["Array"]},"description":"- An array of notation strings."}],"examples":["const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n const notations = Notation.create(obj).getNotations();\n console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]"],"name":"getNotations","longname":"Notation#getNotations","kind":"function","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#getNotations","$kind":"method","$docmaLink":"api/#Notation#getNotations"},{"comment":"/**\n *  `Notation.Glob` is a utility for validating, comparing and sorting\n *  dot-notation globs.\n *\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n *  and negate the notation by prepending a bang `!`. A star will include all\n *  the properties at that level and a negated notation will be excluded.\n *  @name Glob\n *  @memberof Notation\n *  @class\n *\n *  @example\n *  // for the following object;\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\n *\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\n *  'billing.account.id' // represents value `1`\n *  '!billing.account.*' // represents value `{ name: 'John' }`\n *  'name' // represents `'John'`\n *  '*' // represents the whole object\n *\n *  @example\n *  var glob = new Notation.Glob('billing.account.*');\n *  glob.test('billing.account.id'); // true\n */","meta":{"filename":"notation.glob.js","lineno":38,"columnno":0,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"`Notation.Glob` is a utility for validating, comparing and sorting\n dot-notation globs.\n\n You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\n and negate the notation by prepending a bang `!`. A star will include all\n the properties at that level and a negated notation will be excluded.","name":"Glob","memberof":"Notation","kind":"class","examples":["// for the following object;\n { name: 'John', billing: { account: { id: 1, active: true } } };\n\n 'billing.account.*'  // represents value `{ id: 1, active: true }`\n 'billing.account.id' // represents value `1`\n '!billing.account.*' // represents value `{ name: 'John' }`\n 'name' // represents `'John'`\n '*' // represents the whole object\n\n ","var glob = new Notation.Glob('billing.account.*');\n glob.test('billing.account.id'); // true"],"scope":"static","longname":"Notation.Glob","$longname":"Notation.Glob","$kind":"class","$docmaLink":"api/#Notation.Glob","$members":[{"comment":"/**\n     *  Gets the absolute glob notation without the negation prefix `!` and\n     *  redundant trailing wildcards.\n     *  @name Notation.Glob#absGlob\n     *  @type {String}\n     */","meta":{"filename":"notation.glob.js","lineno":97,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the absolute glob notation without the negation prefix `!` and\n redundant trailing wildcards.","name":"absGlob","type":{"names":["String"]},"memberof":"Notation.Glob","longname":"Notation.Glob#absGlob","scope":"instance","kind":"member","$longname":"Notation.Glob#absGlob","$kind":"property","$docmaLink":"api/#Notation.Glob#absGlob"},{"comment":"/**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string) and globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. So\n     *  this works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob comes\n     *  last.\n     *  @name Notation.Glob.compare\n     *  @function\n     *\n     *  @param {String} globA - First notation glob to be compared.\n     *  @param {String} globB - Second notation glob to be compared.\n     *\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\n     *  comes first and `0` if equivalent priority.\n     *\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\n     *  notation.\n     *\n     *  @example\n     *  const { compare } = Notation.Glob;\n     *  compare('*', 'info.user')               // -1\n     *  compare('*', '[*]')                     // 0\n     *  compare('info.*.name', 'info.user')     // 1\n     */","meta":{"filename":"notation.glob.js","lineno":525,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Compares two given notation globs and returns an integer value as a\n result. This is generally used to sort glob arrays. Loose globs (with\n stars especially closer to beginning of the glob string) and globs\n representing the parent/root of the compared property glob come first.\n Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\n\n For instance; `store.address` comes before `store.address.street`. So\n this works both for `*, store.address.street, !store.address` and `*,\n store.address, !store.address.street`. For cases such as `prop.id` vs\n `!prop.id` which represent the same property; the negated glob comes\n last.","name":"compare","kind":"function","params":[{"type":{"names":["String"]},"description":"First notation glob to be compared.","name":"globA"},{"type":{"names":["String"]},"description":"Second notation glob to be compared.","name":"globB"}],"returns":[{"type":{"names":["Number"]},"description":"- Returns `-1` if `globA` comes first, `1` if `globB`\n comes first and `0` if equivalent priority."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If either `globA` or `globB` is invalid glob\n notation."}],"examples":["const { compare } = Notation.Glob;\n compare('*', 'info.user')               // -1\n compare('*', '[*]')                     // 0\n compare('info.*.name', 'info.user')     // 1"],"memberof":"Notation.Glob","longname":"Notation.Glob.compare","scope":"static","$longname":"Notation.Glob.compare","$kind":"method","$docmaLink":"api/#Notation.Glob.compare"},{"comment":"/**\n     *  Specifies whether this glob notation can represent (or cover) the given\n     *  glob notation. Note that negation prefix is ignored, if any.\n     *  @name Notation.Glob#covers\n     *  @function\n     *\n     *  @param {String|Array|Glob} glob  Glob notation string, glob\n     *  notes array or a `Notation.Glob` instance.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('*.y').covers('x.y')      // true\n     *  glob('x[*].y').covers('x[*]')  // false\n     */","meta":{"filename":"notation.glob.js","lineno":220,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Specifies whether this glob notation can represent (or cover) the given\n glob notation. Note that negation prefix is ignored, if any.","name":"covers","kind":"function","params":[{"type":{"names":["String","Array","Glob"]},"description":"Glob notation string, glob\n notes array or a `Notation.Glob` instance.","name":"glob"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"examples":["const glob = Notation.Glob.create;\n glob('*.y').covers('x.y')      // true\n glob('x[*].y').covers('x[*]')  // false"],"memberof":"Notation.Glob","longname":"Notation.Glob#covers","scope":"instance","$longname":"Notation.Glob#covers","$kind":"method","$docmaLink":"api/#Notation.Glob#covers"},{"comment":"/**\n     *  Basically constructs a new `Notation.Glob` instance\n     *  with the given glob string.\n     *  @name Notation.Glob.create\n     *  @function\n     *\n     *  @param {String} glob - The source notation glob.\n     *  @returns {Glob} -\n     *\n     *  @example\n     *  const glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  const glob = new Notation.Glob(strGlob);\n     */","meta":{"filename":"notation.glob.js","lineno":264,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Basically constructs a new `Notation.Glob` instance\n with the given glob string.","name":"create","kind":"function","params":[{"type":{"names":["String"]},"description":"The source notation glob.","name":"glob"}],"returns":[{"type":{"names":["Glob"]},"description":"-"}],"examples":["const glob = Notation.Glob.create(strGlob);\n // equivalent to:\n const glob = new Notation.Glob(strGlob);"],"memberof":"Notation.Glob","longname":"Notation.Glob.create","scope":"static","$longname":"Notation.Glob.create","$kind":"method","$docmaLink":"api/#Notation.Glob.create"},{"comment":"/**\n     *  Gets the first note of this glob notation.\n     *  @name Notation.Glob#first\n     *  @type {String}\n     */","meta":{"filename":"notation.glob.js","lineno":151,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the first note of this glob notation.","name":"first","type":{"names":["String"]},"memberof":"Notation.Glob","longname":"Notation.Glob#first","scope":"instance","kind":"member","$longname":"Notation.Glob#first","$kind":"property","$docmaLink":"api/#Notation.Glob#first"},{"comment":"/**\n     *  Gets the normalized glob notation string.\n     *  @name Notation.Glob#glob\n     *  @type {String}\n     */","meta":{"filename":"notation.glob.js","lineno":88,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the normalized glob notation string.","name":"glob","type":{"names":["String"]},"memberof":"Notation.Glob","longname":"Notation.Glob#glob","scope":"instance","kind":"member","$longname":"Notation.Glob#glob","$kind":"property","$docmaLink":"api/#Notation.Glob#glob"},{"comment":"/**\n     *  Specifies whether the given glob notation includes any valid wildcards\n     *  (`*`) or negation bang prefix (`!`).\n     *  @name Notation.Glob.hasMagic\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be checked.\n     *  @returns {Boolean} -\n     */","meta":{"filename":"notation.glob.js","lineno":295,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Specifies whether the given glob notation includes any valid wildcards\n (`*`) or negation bang prefix (`!`).","name":"hasMagic","kind":"function","params":[{"type":{"names":["String"]},"description":"Glob notation to be checked.","name":"glob"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"memberof":"Notation.Glob","longname":"Notation.Glob.hasMagic","scope":"static","$longname":"Notation.Glob.hasMagic","$kind":"method","$docmaLink":"api/#Notation.Glob.hasMagic"},{"comment":"/**\n     *  Gets the intersection of this and the given glob notations. When\n     *  restrictive, if any one of them is negated, the outcome is negated.\n     *  Otherwise, only if both of them are negated, the outcome is negated.\n     *  @name Notation.Glob#intersect\n     *  @function\n     *\n     *  @param {String} glob - Second glob to be used.\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\n     *  be negated when one of the globs is negated.\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\n     */","meta":{"filename":"notation.glob.js","lineno":239,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the intersection of this and the given glob notations. When\n restrictive, if any one of them is negated, the outcome is negated.\n Otherwise, only if both of them are negated, the outcome is negated.","name":"intersect","kind":"function","params":[{"type":{"names":["String"]},"description":"Second glob to be used.","name":"glob"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether the intersection should\n be negated when one of the globs is negated.","name":"restrictive"}],"returns":[{"type":{"names":["String"]},"description":"- Intersection notation if any; otherwise `null`."}],"examples":["const glob = Notation.Glob.create;\n glob('x.*').intersect('!*.y')         // 'x.y'\n glob('x.*').intersect('!*.y', true)   // '!x.y'"],"memberof":"Notation.Glob","longname":"Notation.Glob#intersect","scope":"instance","$longname":"Notation.Glob#intersect","$kind":"method","$docmaLink":"api/#Notation.Glob#intersect"},{"comment":"/**\n     *  Specifies whether this glob is negated with a `!` prefix.\n     *  @name Notation.Glob#isNegated\n     *  @type {Boolean}\n     */","meta":{"filename":"notation.glob.js","lineno":107,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Specifies whether this glob is negated with a `!` prefix.","name":"isNegated","type":{"names":["Boolean"]},"memberof":"Notation.Glob","longname":"Notation.Glob#isNegated","scope":"instance","kind":"member","$longname":"Notation.Glob#isNegated","$kind":"property","$docmaLink":"api/#Notation.Glob#isNegated"},{"comment":"/**\n     *  Validates the given notation glob.\n     *  @name Notation.Glob.isValid\n     *  @function\n     *\n     *  @param {String} glob - Notation glob to be validated.\n     *  @returns {Boolean} -\n     */","meta":{"filename":"notation.glob.js","lineno":283,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Validates the given notation glob.","name":"isValid","kind":"function","params":[{"type":{"names":["String"]},"description":"Notation glob to be validated.","name":"glob"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"memberof":"Notation.Glob","longname":"Notation.Glob.isValid","scope":"static","$longname":"Notation.Glob.isValid","$kind":"method","$docmaLink":"api/#Notation.Glob.isValid"},{"comment":"/**\n     *  Gets the last note of this glob notation.\n     *  @name Notation.Glob#last\n     *  @type {String}\n     */","meta":{"filename":"notation.glob.js","lineno":160,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the last note of this glob notation.","name":"last","type":{"names":["String"]},"memberof":"Notation.Glob","longname":"Notation.Glob#last","scope":"instance","kind":"member","$longname":"Notation.Glob#last","$kind":"property","$docmaLink":"api/#Notation.Glob#last"},{"comment":"/**\n     *  Normalizes the given notation globs array by removing duplicate or\n     *  redundant items, eliminating extra verbosity (also with intersection\n     *  globs) and returns a priority-sorted globs array.\n     *\n     *  <ul>\n     *  <li>If any exact duplicates found, all except first is removed.\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n     *  <li>If a glob is covered by another, it's removed.\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n     *  <li>If a negated glob is covered by another glob, it's kept.\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\n     *  then we check for for intersection glob. If found, adds them to list;\n     *  removes the original negated.\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n     *  Otherwise, it's kept.\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n     *  </ul>\n     *  @name Notation.Glob.normalize\n     *  @function\n     *\n     *  @param {Array} globList - Notation globs array to be normalized.\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\n     *  remove every match. Note that, regardless of this option, if any item has an\n     *  exact negated version; non-negated is always removed.\n     *  @returns {Array} -\n     *\n     *  @throws {NotationError} - If any item in globs list is invalid.\n     *\n     *  @example\n     *  const { normalize } = Notation.Glob;\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\n     *  normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\n     *  normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\n     *  // restrictive normalize:\n     *  normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]\n     */","meta":{"filename":"notation.glob.js","lineno":610,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Normalizes the given notation globs array by removing duplicate or\n redundant items, eliminating extra verbosity (also with intersection\n globs) and returns a priority-sorted globs array.\n\n <ul>\n <li>If any exact duplicates found, all except first is removed.\n <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\n <li>If both normal and negated versions of a glob are found, negated wins.\n <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\n <li>If a glob is covered by another, it's removed.\n <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\n <li>If a negated glob is covered by another glob, it's kept.\n <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\n <li>If a negated glob is not covered by another or it does not cover any other;\n then we check for for intersection glob. If found, adds them to list;\n removes the original negated.\n <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\n <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\n Otherwise, it's kept.\n <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\n </ul>","name":"normalize","kind":"function","params":[{"type":{"names":["Array"]},"description":"Notation globs array to be normalized.","name":"globList"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether negated items strictly\n remove every match. Note that, regardless of this option, if any item has an\n exact negated version; non-negated is always removed.","name":"restrictive"}],"returns":[{"type":{"names":["Array"]},"description":"-"}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If any item in globs list is invalid."}],"examples":["const { normalize } = Notation.Glob;\n normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\n normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\n normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\n // restrictive normalize:\n normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]"],"memberof":"Notation.Glob","longname":"Notation.Glob.normalize","scope":"static","$longname":"Notation.Glob.normalize","$kind":"method","$docmaLink":"api/#Notation.Glob.normalize"},{"comment":"/**\n     *  List of notes (levels) of this glob notation. Note that trailing,\n     *  redundant wildcards are removed from the original glob notation.\n     *  @name Notation.Glob#notes\n     *  @alias Notation.Glob#levels\n     *  @type {Array}\n     */","meta":{"filename":"notation.glob.js","lineno":129,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"List of notes (levels) of this glob notation. Note that trailing,\n redundant wildcards are removed from the original glob notation.","name":"notes","alias":"Notation.Glob#levels","type":{"names":["Array"]},"memberof":"Notation.Glob","longname":"Notation.Glob#notes","scope":"instance","kind":"member","$longname":"Notation.Glob#notes","$kind":"property","$docmaLink":"api/#Notation.Glob#notes"},{"comment":"/**\n     *  Gets the parent notation (up to but excluding the last note) from the\n     *  glob notation string. Note that initially, trailing/redundant wildcards\n     *  are removed.\n     *  @name Notation.Glob#parent\n     *  @type {String}\n     *\n     *  @example\n     *  const glob = Notation.Glob.create;\n     *  glob('first.second.*').parent;   // \"first.second\"\n     *  glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\n     *  glob('*').parent;                // null (no parent)\n     */","meta":{"filename":"notation.glob.js","lineno":169,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the parent notation (up to but excluding the last note) from the\n glob notation string. Note that initially, trailing/redundant wildcards\n are removed.","name":"parent","type":{"names":["String"]},"examples":["const glob = Notation.Glob.create;\n glob('first.second.*').parent;   // \"first.second\"\n glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\n glob('*').parent;                // null (no parent)"],"memberof":"Notation.Glob","longname":"Notation.Glob#parent","scope":"instance","kind":"member","$longname":"Notation.Glob#parent","$kind":"property","$docmaLink":"api/#Notation.Glob#parent"},{"comment":"/**\n     *  Represents this glob in regular expressions.\n     *  Note that the negation prefix (`!`) is ignored, if any.\n     *  @name Notation.Glob#regexp\n     *  @type {RegExp}\n     */","meta":{"filename":"notation.glob.js","lineno":116,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Represents this glob in regular expressions.\n Note that the negation prefix (`!`) is ignored, if any.","name":"regexp","type":{"names":["RegExp"]},"memberof":"Notation.Glob","longname":"Notation.Glob#regexp","scope":"instance","kind":"member","$longname":"Notation.Glob#regexp","$kind":"property","$docmaLink":"api/#Notation.Glob#regexp"},{"comment":"/**\n     *  Sorts the notation globs in the given array by their priorities. Loose\n     *  globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come\n     *  first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\n     *\n     *  For instance; `store.address` comes before `store.address.street`. For\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\n     *  the negated glob wins (comes last).\n     *  @name Notation.Glob.sort\n     *  @function\n     *\n     *  @param {Array} globList - The notation globs array to be sorted. The\n     *  passed array reference is modified.\n     *  @returns {Array} - Logically sorted globs array.\n     *\n     *  @example\n     *  Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];\n     */","meta":{"filename":"notation.glob.js","lineno":587,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Sorts the notation globs in the given array by their priorities. Loose\n globs (with stars especially closer to beginning of the glob string);\n globs representing the parent/root of the compared property glob come\n first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\n\n For instance; `store.address` comes before `store.address.street`. For\n cases such as `prop.id` vs `!prop.id` which represent the same property;\n the negated glob wins (comes last).","name":"sort","kind":"function","params":[{"type":{"names":["Array"]},"description":"The notation globs array to be sorted. The\n passed array reference is modified.","name":"globList"}],"returns":[{"type":{"names":["Array"]},"description":"- Logically sorted globs array."}],"examples":["Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];"],"memberof":"Notation.Glob","longname":"Notation.Glob.sort","scope":"static","$longname":"Notation.Glob.sort","$kind":"method","$docmaLink":"api/#Notation.Glob.sort"},{"comment":"/**\n     *  Splits the given glob notation string into its notes (levels). Note that\n     *  this will exclude the `!` negation prefix, if it exists.\n     *  @name Notation.Glob.split\n     *  @function\n     *\n     *  @param {String} glob  Glob notation string to be splitted.\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\n     *  wildcards.\n     *  @returns {Array} - A string array of glob notes (levels).\n     *  @throws {NotationError} - If given glob notation is invalid.\n     *\n     *  @example\n     *  Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\n     */","meta":{"filename":"notation.glob.js","lineno":499,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Splits the given glob notation string into its notes (levels). Note that\n this will exclude the `!` negation prefix, if it exists.","name":"split","kind":"function","params":[{"type":{"names":["String"]},"description":"Glob notation string to be splitted.","name":"glob"},{"type":{"names":["String"]},"optional":true,"defaultvalue":false,"description":"Whether to remove trailing, redundant\n wildcards.","name":"normalize"}],"returns":[{"type":{"names":["Array"]},"description":"- A string array of glob notes (levels)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given glob notation is invalid."}],"examples":["Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\n // you can get the same result from the .notes property of a Notation.Glob instance."],"memberof":"Notation.Glob","longname":"Notation.Glob.split","scope":"static","$longname":"Notation.Glob.split","$kind":"method","$docmaLink":"api/#Notation.Glob.split"},{"comment":"/**\n     *  Checks whether the given notation value matches the source notation\n     *  glob.\n     *  @name Notation.Glob#test\n     *  @function\n     *  @param {String} notation - The notation string to be tested. Cannot have\n     *  any globs.\n     *  @returns {Boolean} -\n     *  @throws {NotationError} - If given `notation` is not valid or contains\n     *  any globs.\n     *\n     *  @example\n     *  const glob = new Notation.Glob('!prop.*.name');\n     *  glob.test(\"prop.account.name\"); // true\n     */","meta":{"filename":"notation.glob.js","lineno":197,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Checks whether the given notation value matches the source notation\n glob.","name":"test","kind":"function","params":[{"type":{"names":["String"]},"description":"The notation string to be tested. Cannot have\n any globs.","name":"notation"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given `notation` is not valid or contains\n any globs."}],"examples":["const glob = new Notation.Glob('!prop.*.name');\n glob.test(\"prop.account.name\"); // true"],"memberof":"Notation.Glob","longname":"Notation.Glob#test","scope":"instance","$longname":"Notation.Glob#test","$kind":"method","$docmaLink":"api/#Notation.Glob#test"},{"comment":"/**\n     *  Gets a regular expressions instance from the given glob notation.\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\n     *  @name Notation.Glob.toRegExp\n     *  @function\n     *\n     *  @param {String} glob - Glob notation to be converted.\n     *\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */","meta":{"filename":"notation.glob.js","lineno":308,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets a regular expressions instance from the given glob notation.\n Note that the bang `!` prefix will be ignored if the given glob is negated.","name":"toRegExp","kind":"function","params":[{"type":{"names":["String"]},"description":"Glob notation to be converted.","name":"glob"}],"returns":[{"type":{"names":["RegExp"]},"description":"- A `RegExp` instance from the glob."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation glob is invalid."}],"memberof":"Notation.Glob","longname":"Notation.Glob.toRegExp","scope":"static","$longname":"Notation.Glob.toRegExp","$kind":"method","$docmaLink":"api/#Notation.Glob.toRegExp"},{"comment":"/**\n     *  Gets the union from the given couple of glob arrays and returns a new\n     *  array of globs.\n     *  <ul>\n     *  <li>If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates.\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n     *  <li>If any non-negated item is covered by a glob in the same\n     *  or other array, the redundant item is removed.\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n     *  <li>If one of the arrays contains a negated equivalent of an\n     *  item in the other array, the negated item is removed.\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n     *  <li>If any item covers/matches a negated item in the other array,\n     *  the negated item is removed.\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n     *  </li>\n     *  </ul>\n     *  @name Notation.Glob.union\n     *  @function\n     *\n     *  @param {Array} globsA - First array of glob strings.\n     *  @param {Array} globsB - Second array of glob strings.\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\n     *  the lists, strictly remove every match in themselves (not the cross\n     *  list). This option is used when pre-normalizing each glob list and\n     *  normalizing the final union list.\n     *\n     *  @returns {Array} -\n     *\n     *  @example\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\n     *  const { union } = Notation.Glob;\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\n     */","meta":{"filename":"notation.glob.js","lineno":934,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Gets the union from the given couple of glob arrays and returns a new\n array of globs.\n <ul>\n <li>If the exact same element is found in both\n arrays, one of them is removed to prevent duplicates.\n <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\n <li>If any non-negated item is covered by a glob in the same\n or other array, the redundant item is removed.\n <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\n <li>If one of the arrays contains a negated equivalent of an\n item in the other array, the negated item is removed.\n <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\n <li>If any item covers/matches a negated item in the other array,\n the negated item is removed.\n <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\n <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\n </li>\n </ul>","name":"union","kind":"function","params":[{"type":{"names":["Array"]},"description":"First array of glob strings.","name":"globsA"},{"type":{"names":["Array"]},"description":"Second array of glob strings.","name":"globsB"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":false,"description":"Whether negated items in each of\n the lists, strictly remove every match in themselves (not the cross\n list). This option is used when pre-normalizing each glob list and\n normalizing the final union list.","name":"restrictive"}],"returns":[{"type":{"names":["Array"]},"description":"-"}],"examples":["const a = ['user.*', '!user.email', 'car.model', '!*.id'];\n const b = ['!*.date', 'user.email', 'car', '*.age'];\n const { union } = Notation.Glob;\n union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']"],"memberof":"Notation.Glob","longname":"Notation.Glob.union","scope":"static","$longname":"Notation.Glob.union","$kind":"method","$docmaLink":"api/#Notation.Glob.union"}],"$constructor":{"comment":"/**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructs Notation.Glob\n     *  @param {String} glob - Notation string with globs.\n     *\n     *  @throws {NotationError} - If given notation glob is invalid.\n     */","meta":{"range":[2790,3114],"filename":"notation.glob.js","lineno":72,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100000163","name":"Glob","type":"MethodDefinition","paramnames":["glob"]},"vars":{"":null}},"description":"Constructs a `Notation.Glob` object with the given glob string.","alias":"Notation.Glob","kind":"class","params":[{"type":{"names":["String"]},"description":"Notation string with globs.","name":"glob"}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation glob is invalid."}],"name":"Glob","longname":"Notation.Glob","memberof":"Notation","scope":"static","$longname":"Notation.Glob","$kind":"constructor","$docmaLink":"api/#Notation.Glob"}},{"comment":"/**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */","meta":{"range":[17380,17447],"filename":"notation.js","lineno":451,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003151","name":"Notation#has","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Checks whether the source object has the given notation\n as a (leveled) enumerable property. If the property exists\n but has a value of `undefined`, this will still return `true`.","params":[{"type":{"names":["String"]},"description":"The notation string to be checked.","name":"notation"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"examples":["Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n Notation.create({}).has(\"car.color\"); // false"],"name":"has","longname":"Notation#has","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#has","$kind":"method","$docmaLink":"api/#Notation#has"},{"comment":"/**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */","meta":{"range":[18027,18117],"filename":"notation.js","lineno":467,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003164","name":"Notation#hasDefined","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Checks whether the source object has the given notation\n as a (leveled) defined enumerable property. If the property\n exists but has a value of `undefined`, this will return `false`.","params":[{"type":{"names":["String"]},"description":"The notation string to be checked.","name":"notation"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"examples":["Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n Notation.create({}).hasDefined(\"car.color\"); // false"],"name":"hasDefined","longname":"Notation#hasDefined","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#hasDefined","$kind":"method","$docmaLink":"api/#Notation#hasDefined"},{"comment":"/**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *  @param {String} notation - The notation string to be inspected.\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\n     *  // { has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\n     */","meta":{"range":[11334,12624],"filename":"notation.js","lineno":308,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002845","name":"Notation#inspectGet","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Inspects the given notation on the source object by checking\n if the source object actually has the notated property;\n and getting its value if exists.","params":[{"type":{"names":["String"]},"description":"The notation string to be inspected.","name":"notation"}],"returns":[{"type":{"names":["InspectResult"]},"description":"- The result object."}],"examples":["Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\n // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\n Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\n // { has: false }\n Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\n // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\n Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\n // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }"],"name":"inspectGet","longname":"Notation#inspectGet","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#inspectGet","$kind":"method","$docmaLink":"api/#Notation#inspectGet"},{"comment":"/**\n     *  Inspects and removes the given notation from the source object by\n     *  checking if the source object actually has the notated property; and\n     *  getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @returns {InspectResult} - The result object.\n     *\n     *  @example\n     *  const obj = { name: \"John\", car: { year: 1970 } };\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n     *  // obj » { name: \"John\", car: {} }\n     *\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // result » { notation: \"car.color\", has: false }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n     *\n     *  const obj = { car: { colors: [\"black\", \"white\"] } };\n     *  const result = Notation.create().inspectRemove(\"car.colors[0]\");\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\n     */","meta":{"range":[15239,16825],"filename":"notation.js","lineno":393,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002983","name":"Notation#inspectRemove","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Inspects and removes the given notation from the source object by\n checking if the source object actually has the notated property; and\n getting its value if exists, before removing the property.","params":[{"type":{"names":["String"]},"description":"The notation string to be inspected.","name":"notation"}],"returns":[{"type":{"names":["InspectResult"]},"description":"- The result object."}],"examples":["const obj = { name: \"John\", car: { year: 1970 } };\n let result = Notation.create(obj).inspectRemove(\"car.year\");\n // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\n // obj » { name: \"John\", car: {} }\n\n result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n // result » { notation: \"car.color\", has: false }\n Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\n // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\n\n const obj = { car: { colors: [\"black\", \"white\"] } };\n const result = Notation.create().inspectRemove(\"car.colors[0]\");\n // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\n // obj » { car: { colors: [(empty), \"white\"] } }"],"name":"inspectRemove","longname":"Notation#inspectRemove","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#inspectRemove","$kind":"method","$docmaLink":"api/#Notation#inspectRemove"},{"comment":"/**\n     *  Notation inspection result object.\n     *  @typedef Notation~InspectResult\n     *  @type Object\n     *  @property {String} notation - Notation that is inspected.\n     *  @property {Boolean} has - Indicates whether the source object has the\n     *  given notation as a (leveled) enumerable property. If the property\n     *  exists but has a value of `undefined`, this will still return `true`.\n     *  @property {*} value - The value of the notated property. If the source\n     *  object does not have the notation, the value will be `undefined`.\n     *  @property {String} type - The type of the notated property. If the source\n     *  object does not have the notation, the type will be `\"undefined\"`.\n     *  @property {String} lastNote - Last note of the notation, if actually\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\n     *  of the last note of the notation, if actually exists. For example, last\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n     *  indicates an array index.\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\n     *  notation path is an array.\n     */","meta":{"filename":"notation.js","lineno":346,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{}},"description":"Notation inspection result object.","kind":"typedef","name":"InspectResult","type":{"names":["Object"]},"properties":[{"type":{"names":["Boolean"]},"description":"Indicates whether the source object has the\n given notation as a (leveled) enumerable property. If the property\n exists but has a value of `undefined`, this will still return `true`.","name":"has"},{"type":{"names":["String"]},"description":"Last note of the notation, if actually\n exists. For example, last note of `'a.b.c'` is `'c'`.","name":"lastNote"},{"type":{"names":["String","Number"]},"description":"Normalized representation\n of the last note of the notation, if actually exists. For example, last\n note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\n indicates an array index.","name":"lastNoteNormalized"},{"type":{"names":["String"]},"description":"Notation that is inspected.","name":"notation"},{"type":{"names":["Boolean"]},"description":"Whether the parent object of the\n notation path is an array.","name":"parentIsArray"},{"type":{"names":["String"]},"description":"The type of the notated property. If the source\n object does not have the notation, the type will be `\"undefined\"`.","name":"type"},{"type":{"names":["*"]},"description":"The value of the notated property. If the source\n object does not have the notation, the value will be `undefined`.","name":"value"}],"memberof":"Notation","longname":"Notation~InspectResult","scope":"inner","$longname":"Notation~InspectResult","$kind":"typedef","$docmaLink":"api/#Notation~InspectResult"},{"comment":"/**\n     *  Checks whether the given notation string is valid. Note that the star\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\n     *  goes for the negation character/prefix (`!`).\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *  @returns {Boolean} -\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('x'); // true\n     *  Notation.isValid('x.arr[0].y'); // true\n     *  Notation.isValid('x[\"*\"]'); // true\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\n     *  Notation.isValid(null); // false\n     */","meta":{"range":[52632,52739],"filename":"notation.js","lineno":1239,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004527","name":"Notation.isValid","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Checks whether the given notation string is valid. Note that the star\n (`*`) (which is a valid character, even if irregular) is NOT treated as\n wildcard here. This checks for regular dot-notation, not a glob-notation.\n For glob notation validation, use `Notation.Glob.isValid()` method. Same\n goes for the negation character/prefix (`!`).","params":[{"type":{"names":["String"]},"description":"The notation string to be checked.","name":"notation"}],"returns":[{"type":{"names":["Boolean"]},"description":"-"}],"examples":["Notation.isValid('prop1.prop2.prop3'); // true\n Notation.isValid('x'); // true\n Notation.isValid('x.arr[0].y'); // true\n Notation.isValid('x[\"*\"]'); // true\n Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\n Notation.isValid('@1'); // false (should be \"['@1']\")\n Notation.isValid(null); // false"],"name":"isValid","longname":"Notation.isValid","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.isValid","$kind":"method","$docmaLink":"api/#Notation.isValid"},{"comment":"/**\n     *  Joins the given notes into a notation string.\n     *  @param {String} notes  Notes (levels) to be joined.\n     *  @returns {String}  Joined notation string.\n     */","meta":{"range":[53399,53464],"filename":"notation.js","lineno":1261,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004573","name":"Notation.join","type":"MethodDefinition","paramnames":["notes"]},"vars":{"":null}},"description":"Joins the given notes into a notation string.","params":[{"type":{"names":["String"]},"description":"Notes (levels) to be joined.","name":"notes"}],"returns":[{"type":{"names":["String"]},"description":"Joined notation string."}],"name":"join","longname":"Notation.join","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.join","$kind":"method","$docmaLink":"api/#Notation.join"},{"comment":"/**\n     *  Gets the last note of the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Last note.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */","meta":{"range":[54810,54924],"filename":"notation.js","lineno":1308,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004621","name":"Notation.last","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Gets the last note of the notation string.","params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"}],"returns":[{"type":{"names":["String"]},"description":"- Last note."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"examples":["Notation.last('first.prop2.last'); // \"last\""],"name":"last","longname":"Notation.last","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.last","$kind":"method","$docmaLink":"api/#Notation.last"},{"comment":"/**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *  @chainable\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *  This can either be a regular object with non-dotted keys\n     *  (which will be merged to the first/root level of the source object);\n     *  or a flattened object with notated (dotted) keys.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\n     *  exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj).merge({\n     *      \"car.brand\": \"Ford\",\n     *      \"car.model\": \"Mustang\",\n     *      \"car.year\": 1965,\n     *      \"car.color\": \"red\",\n     *      \"boat\": \"none\"\n     *  });\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */","meta":{"range":[25259,25660],"filename":"notation.js","lineno":623,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003477","name":"Notation#merge","type":"MethodDefinition","paramnames":["notationsObject","overwrite"]},"vars":{"":null}},"description":"Just like the `.set()` method but instead of a single notation\n string, an object of notations and values can be passed.\n Sets the value of each corresponding property at the given\n notation. If a property does not exist, it will be created\n and nested at the calculated level. If it exists; its value\n will be overwritten by default.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object"]},"description":"The notations object to be processed.\n This can either be a regular object with non-dotted keys\n (which will be merged to the first/root level of the source object);\n or a flattened object with notated (dotted) keys.","name":"notationsObject"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite a property if\n exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"examples":["const obj = { car: { brand: \"Dodge\", year: 1970 } };\n Notation.create(obj).merge({\n     \"car.brand\": \"Ford\",\n     \"car.model\": \"Mustang\",\n     \"car.year\": 1965,\n     \"car.color\": \"red\",\n     \"boat\": \"none\"\n });\n console.log(obj);\n // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };"],"name":"merge","longname":"Notation#merge","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#merge","$kind":"method","$docmaLink":"api/#Notation#merge"},{"comment":"/**\n     *  Removes the notated property from the target collection and adds it to (own)\n     *  source collection — only if the target object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} target - The target collection that the notated\n     *  properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *  from the target object.\n     *  @param {String} [newNotation=null] - The notation to set the target\n     *  property on the source object. In other words, the moved property\n     *  will be renamed to this value before set on the source object.\n     *  If not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the source object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `target` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */","meta":{"range":[45752,46152],"filename":"notation.js","lineno":1059,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004343","name":"Notation#moveFrom","type":"MethodDefinition","paramnames":["target","notation","newNotation","overwrite"]},"vars":{"":null}},"description":"Removes the notated property from the target collection and adds it to (own)\n source collection — only if the target object actually has that property.\n This is different than a property with a value of `undefined`.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object","Array"]},"description":"The target collection that the notated\n properties will be moved from.","name":"target"},{"type":{"names":["String"]},"description":"The notation to get the corresponding property\n from the target object.","name":"notation"},{"type":{"names":["String"]},"optional":true,"defaultvalue":null,"description":"The notation to set the target\n property on the source object. In other words, the moved property\n will be renamed to this value before set on the source object.\n If not set, `notation` argument will be used.","name":"newNotation"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite the property on\n the source object if it exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `target` is not a valid collection."},{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const models = { dodge: \"Charger\" };\n Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\n console.log(obj);\n // { car: { brand: \"Ford\", model: \"Charger\" } }\n console.log(models);\n // {}"],"name":"moveFrom","longname":"Notation#moveFrom","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#moveFrom","$kind":"method","$docmaLink":"api/#Notation#moveFrom"},{"comment":"/**\n     *  Removes the notated property from the source (own) collection and adds\n     *  it to the destination — only if the source collection actually has that\n     *  property. This is different than a property with a value of `undefined`.\n     *  @chainable\n     *\n     *  @param {Object|Array} destination - The destination collection that the\n     *  notated properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding\n     *  property from the source object.\n     *  @param {String} [newNotation=null] - The notation to set the source\n     *  property on the destination object. In other words, the moved property\n     *  will be renamed to this value before set on the destination object. If\n     *  not set, `notation` argument will be used.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\n     *  the destination object if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `destination` is not a valid collection.\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  const models = { dodge: \"Charger\" };\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(obj);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */","meta":{"range":[43857,44270],"filename":"notation.js","lineno":1018,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004280","name":"Notation#moveTo","type":"MethodDefinition","paramnames":["destination","notation","newNotation","overwrite"]},"vars":{"":null}},"description":"Removes the notated property from the source (own) collection and adds\n it to the destination — only if the source collection actually has that\n property. This is different than a property with a value of `undefined`.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["Object","Array"]},"description":"The destination collection that the\n notated properties will be moved to.","name":"destination"},{"type":{"names":["String"]},"description":"The notation to get the corresponding\n property from the source object.","name":"notation"},{"type":{"names":["String"]},"optional":true,"defaultvalue":null,"description":"The notation to set the source\n property on the destination object. In other words, the moved property\n will be renamed to this value before set on the destination object. If\n not set, `notation` argument will be used.","name":"newNotation"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite the property on\n the destination object if it exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `destination` is not a valid collection."},{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n const models = { dodge: \"Charger\" };\n Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\n console.log(obj);\n // { car: { brand: \"Ford\" } }\n console.log(models);\n // { dodge: \"Charger\", ford: \"Mustang\" }"],"name":"moveTo","longname":"Notation#moveTo","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#moveTo","$kind":"method","$docmaLink":"api/#Notation#moveTo"},{"comment":"/**\n     *  Initializes a new `Notation.Error` instance.\n     *  @hideconstructor\n     *  @constructs Notation.Error\n     *  @param {String} message - The error message.\n     */","meta":{"range":[405,1182],"filename":"notation.error.js","lineno":18,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100000012","name":"NotationError","type":"MethodDefinition","paramnames":["message"]},"vars":{"":null}},"description":"Initializes a new `Notation.Error` instance.","hideconstructor":true,"alias":"Notation.Error","kind":"class","params":[{"type":{"names":["String"]},"description":"The error message.","name":"message"}],"name":"Error","longname":"Notation.Error","memberof":"Notation","scope":"static","$longname":"Notation.NotationError","$kind":"constructor","$docmaLink":"api/#Notation.NotationError","$hide":true},{"comment":"/**\n     *  Gets or sets notation options.\n     *  @type {Object}\n     */","meta":{"range":[3898,3949],"filename":"notation.js","lineno":100,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002633","name":"Notation#options","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Gets or sets notation options.","type":{"names":["Object"]},"name":"options","longname":"Notation#options","kind":"member","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#options","$kind":"property","$docmaLink":"api/#Notation#options"},{"comment":"/**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *  @param {String} notation - The notation string to be processed.\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\n     *  @throws {NotationError} - If given notation is invalid.\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */","meta":{"range":[55381,55533],"filename":"notation.js","lineno":1324,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004642","name":"Notation.parent","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Gets the parent notation (up to but excluding the last note)\n from the notation string.","params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"}],"returns":[{"type":{"names":["String"]},"description":"- Parent note if any. Otherwise, `null`."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"examples":["Notation.parent('first.prop2.last'); // \"first.prop2\"\n Notation.parent('single'); // null"],"name":"parent","longname":"Notation.parent","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.parent","$kind":"method","$docmaLink":"api/#Notation.parent"},{"comment":"/**\n     *  Removes the property from the source object, at the given notation.\n     *  @alias Notation#delete\n     *  @chainable\n     *  @param {String} notation - The notation to be inspected.\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *  @throws {NotationError} - If `strict` option is enabled and notation\n     *  does not exist.\n     *\n     *  @example\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(obj).remove(\"car.model\");\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\n     */","meta":{"range":[38015,38368],"filename":"notation.js","lineno":886,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004092","name":"Notation#remove","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Removes the property from the source object, at the given notation.","alias":"Notation#delete","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["String"]},"description":"The notation to be inspected.","name":"notation"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `strict` option is enabled and notation\n does not exist."}],"examples":["const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n Notation.create(obj).remove(\"car.model\");\n console.log(obj); // { notebook: \"Mac\", car: { } }"],"name":"delete","longname":"Notation#delete","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#remove","$kind":"method","$docmaLink":"api/#Notation#remove"},{"comment":"/**\n     *  Renames the notated property of the source collection by the new notation.\n     *  @alias Notation#renote\n     *  @chainable\n     *\n     *  @param {String} notation - The notation to get the corresponding\n     *  property (value) from the source collection.\n     *  @param {String} newNotation - The new notation for the targeted\n     *  property value. If not set, the source collection will not be modified.\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\n     *  the new notation, if it exists.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(obj)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(obj);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */","meta":{"range":[47163,47287],"filename":"notation.js","lineno":1093,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004406","name":"Notation#rename","type":"MethodDefinition","paramnames":["notation","newNotation","overwrite"]},"vars":{"":null}},"description":"Renames the notated property of the source collection by the new notation.","alias":"Notation#renote","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["String"]},"description":"The notation to get the corresponding\n property (value) from the source collection.","name":"notation"},{"type":{"names":["String"]},"description":"The new notation for the targeted\n property value. If not set, the source collection will not be modified.","name":"newNotation"},{"type":{"names":["Boolean"]},"optional":true,"defaultvalue":true,"description":"Whether to overwrite the property at\n the new notation, if it exists.","name":"overwrite"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If `notation` or `newNotation` is invalid."}],"examples":["const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\n Notation.create(obj)\n     .rename(\"car.brand\", \"carBrand\")\n     .rename(\"car.model\", \"carModel\");\n console.log(obj);\n // { carBrand: \"Ford\", carModel: \"Mustang\" }"],"name":"renote","longname":"Notation#renote","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#rename","$kind":"method","$docmaLink":"api/#Notation#rename"},{"comment":"/**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notations - The notations array to be processed.\n     *\n     *  @returns {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(obj);\n     *  // { car: { year: 1970 } };\n     */","meta":{"range":[26353,26760],"filename":"notation.js","lineno":652,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003534","name":"Notation#separate","type":"MethodDefinition","paramnames":["notations"]},"vars":{"":null}},"description":"Removes the properties by the given list of notations from the source\n object and returns a new object with the removed properties.\n Opposite of `merge()` method.","params":[{"type":{"names":["Array"]},"description":"The notations array to be processed.","name":"notations"}],"returns":[{"type":{"names":["Object"]},"description":"- An object with the removed properties."}],"examples":["const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\n console.log(separated);\n // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n console.log(obj);\n // { car: { year: 1970 } };"],"name":"separate","longname":"Notation#separate","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#separate","$kind":"method","$docmaLink":"api/#Notation#separate"},{"comment":"/**\n     *  Sets the value of the corresponding property at the given notation. If\n     *  the property does not exist, it will be created and nested at the\n     *  calculated level. If it exists; its value will be overwritten by\n     *  default.\n     *  @chainable\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {String|Boolean} [mode=\"overwrite\"] - Write mode. By default,\n     *  this is set to `\"overwrite\"` which sets the value by overwriting the\n     *  target object property or array item at index. To insert an array item\n     *  (by shifting the index, instead of overwriting); set to `\"insert\"`. To\n     *  prevent overwriting the value if exists, explicitly set to `false`.\n     *\n     *  @returns {Notation} - The current `Notation` instance (self).\n     *\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\n     *  option is set to `false` and attempted to overwrite an existing value.\n     *\n     *  @example\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(obj)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(obj);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\n     */","meta":{"range":[21343,23966],"filename":"notation.js","lineno":537,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100003242","name":"Notation#set","type":"MethodDefinition","paramnames":["notation","value","mode"]},"vars":{"":null}},"description":"Sets the value of the corresponding property at the given notation. If\n the property does not exist, it will be created and nested at the\n calculated level. If it exists; its value will be overwritten by\n default.","tags":[{"originalTitle":"chainable","title":"chainable","text":""}],"params":[{"type":{"names":["String"]},"description":"The notation string to be processed.","name":"notation"},{"type":{"names":["*"]},"description":"The value to be set for the notated property.","name":"value"},{"type":{"names":["String","Boolean"]},"optional":true,"defaultvalue":"\"overwrite\"","description":"Write mode. By default,\n this is set to `\"overwrite\"` which sets the value by overwriting the\n target object property or array item at index. To insert an array item\n (by shifting the index, instead of overwriting); set to `\"insert\"`. To\n prevent overwriting the value if exists, explicitly set to `false`.","name":"mode"}],"returns":[{"type":{"names":["Notation"]},"description":"- The current `Notation` instance (self)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If strict notation is enabled, `overwrite`\n option is set to `false` and attempted to overwrite an existing value."}],"examples":["const obj = { car: { brand: \"Dodge\", year: 1970 } };\n Notation.create(obj)\n     .set(\"car.brand\", \"Ford\")\n     .set(\"car.model\", \"Mustang\")\n     .set(\"car.year\", 1965, false)\n     .set(\"car.color\", \"red\")\n     .set(\"boat\", \"none\");\n console.log(obj);\n // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };"],"name":"set","longname":"Notation#set","kind":"function","memberof":"Notation","scope":"instance","$longname":"Notation#set","$kind":"method","$docmaLink":"api/#Notation#set"},{"comment":"/**\n     *  Splits the given notation string into its notes (levels).\n     *  @param {String} notation  Notation string to be splitted.\n     *  @returns {Array} - A string array of notes (levels).\n     *  @throws {NotationError} - If given notation is invalid.\n     */","meta":{"range":[53018,53212],"filename":"notation.js","lineno":1249,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100004543","name":"Notation.split","type":"MethodDefinition","paramnames":["notation"]},"vars":{"":null}},"description":"Splits the given notation string into its notes (levels).","params":[{"type":{"names":["String"]},"description":"Notation string to be splitted.","name":"notation"}],"returns":[{"type":{"names":["Array"]},"description":"- A string array of notes (levels)."}],"exceptions":[{"type":{"names":["NotationError"]},"description":"- If given notation is invalid."}],"name":"split","longname":"Notation.split","kind":"function","memberof":"Notation","scope":"static","$longname":"Notation.split","$kind":"method","$docmaLink":"api/#Notation.split"},{"comment":"/**\n     *  Gets the value of the source object.\n     *  @type {Object|Array}\n     *\n     *  @example\n     *  const person = { name: \"Onur\" };\n     *  const me = Notation.create(person)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(person === me); // true\n     */","meta":{"range":[4585,4633],"filename":"notation.js","lineno":126,"columnno":4,"path":"/Users/oy/Developer/@onury/notation/src/core","code":{"id":"astnode100002664","name":"Notation#value","type":"MethodDefinition","paramnames":[]},"vars":{"":null}},"description":"Gets the value of the source object.","type":{"names":["Object","Array"]},"examples":["const person = { name: \"Onur\" };\n const me = Notation.create(person)\n     .set(\"age\", 36)\n     .set(\"car.brand\", \"Ford\")\n     .set(\"car.model\", \"Mustang\")\n     .value;\n console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n console.log(person === me); // true"],"name":"value","longname":"Notation#value","kind":"member","memberof":"Notation","scope":"instance","params":[],"$longname":"Notation#value","$kind":"property","$docmaLink":"api/#Notation#value"}],"symbols":["Notation","Notation","Notation#clone","Notation#copyFrom","Notation#copyTo","Notation.countNotes","Notation.create","Notation#each","Notation.eachNote","Notation#eachValue","Notation.Error","Notation#expand","Notation#extract","Notation#extrude","Notation#filter","Notation.first","Notation#flatten","Notation#get","Notation#getNotations","Notation.Glob","Notation.Glob#absGlob","Notation.Glob.compare","Notation.Glob#covers","Notation.Glob.create","Notation.Glob#first","Notation.Glob#glob","Notation.Glob.hasMagic","Notation.Glob#intersect","Notation.Glob#isNegated","Notation.Glob.isValid","Notation.Glob#last","Notation.Glob.normalize","Notation.Glob#notes","Notation.Glob#parent","Notation.Glob#regexp","Notation.Glob.sort","Notation.Glob.split","Notation.Glob#test","Notation.Glob.toRegExp","Notation.Glob.union","Notation#has","Notation#hasDefined","Notation#inspectGet","Notation#inspectRemove","Notation~InspectResult","Notation.isValid","Notation.join","Notation.last","Notation#merge","Notation#moveFrom","Notation#moveTo","Notation.NotationError","Notation#options","Notation.parent","Notation#remove","Notation#rename","Notation#separate","Notation#set","Notation.split","Notation#value"]}},"app":{"title":"Notation","meta":null,"base":"/notation/","entrance":"content:guide","routing":{"method":"path","caseSensitive":true},"server":"github","favicon":""},"template":{"name":"docma-template-zebra","description":"Zebra - Default template for Docma. https://github.com/onury/docma","version":"2.3.1","supportedDocmaVersion":">=2.0.0","author":"Onur Yıldırım","license":"MIT","mainHTML":"index.html","options":{"title":{"label":"Notation","href":"/notation/"},"logo":null,"sidebar":{"enabled":true,"outline":"tree","collapsed":false,"toolbar":true,"itemsFolded":false,"itemsOverflow":"crop","badges":true,"search":true,"animations":true},"symbols":{"autoLink":true,"params":"list","enums":"list","props":"list","meta":false},"contentView":{"bookmarks":"h1,h2,h3","faVersion":"5.5.0","faLibs":"all"},"navbar":{"enabled":true,"fixed":true,"dark":false,"animations":true,"menu":[{"label":"Guide","href":"guide/"},{"label":"API Reference","href":"api/"},{"label":"Releases","items":[{"label":"<code>npm i notation</code>"},{"separator":true},{"label":"Download as Archive","href":"https://github.com/onury/notation/releases","target":"_blank"},{"separator":true},{"label":"Change-Log","href":"changelog/"}],"chevron":true},{"iconClass":"fa-lg fab fa-github","label":"GitHub","href":"https://github.com/onury/notation","target":"_blank"}]}}},"partials":{"api":"docma-api","content":"docma-content","notFound":"docma-404"},"elementID":"docma-main","contentElementID":"docma-content","defaultApiName":"_def_","logsEnabled":false}));

!function(){"use strict";var c="path"===docma.app.routing.method;function n(a){return(a.params[1]||"").replace(/\/$/,"")}function a(a,e){var o=n(a)||docma._.defaultApiName,t=docma.createRoute(o,DocmaWeb.Route.Type.API);if(!t||!t.exists())return e();t.apply()}docma.app.base&&page.base(docma.app.base),page.redirect("(/)?"+docma.template.main,""),c&&(page("(/)?api/(.+)",a),page("(/)?api(/)?",a),page("(/)?(.*)",function(a,e){var o=n(a),t=docma.createRoute(o,DocmaWeb.Route.Type.CONTENT);if(!t||!t.exists())return e();t.apply()})),page("(/)?",function(t,n){!function(){if(c){var a=sessionStorage.getItem("redirectPath")||null;if(a)return sessionStorage.removeItem("redirectPath"),docma.info("Redirecting to:",a),page.redirect(a),!0}return!1}()&&setTimeout(function(){var a,e=function(a){var e=a||window.location.search;return/^[?&]/.test(e)&&(e=e.slice(1)),e||null}(t.querystring);if(c){if(e)return n();a=docma._.appEntranceRI}else docma.log("Query-string:",e),a=e?docma.createRouteFromQuery(e):docma._.appEntranceRI;if(!a||!a.exists())return n();function o(){docma._trigger(DocmaWeb.Event.Navigate,[a])}a.isCurrent()?o():a.apply(function(a){200===a&&o()})},100)}),page("*",function(a){docma.warn("Unknown Route:",a.path),docma.log("context:",a),docma.createRoute(null).apply()}),docma.info("Docma SPA Configuration:"),docma.info("App Title:          ",docma.app.title),docma.info("Routing Method:     ",docma.app.routing.method),docma.info("App Server:         ",docma.app.server),docma.info("Base Path:          ",docma.app.base),docma.info("Entrance Route ID:  ",docma.app.entrance),window.onload=function(){docma._.initialLoad=!0,docma._.appEntranceRI=docma.createRouteFromID(docma.app.entrance),page.start({click:!0,popstate:!0,dispatch:!0,hashbang:!1,decodeURLComponents:!0}),docma.info("Docma SPA loaded!")}}();